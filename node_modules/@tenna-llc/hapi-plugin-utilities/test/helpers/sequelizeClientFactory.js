'use strict';

const Lab = require('@hapi/lab');
const Code = require('@hapi/code');
const { Sequelize } = require('sequelize');
const { SequelizeClientFactory } = require('../../src/helpers');

const { before, after, beforeEach, afterEach, describe, it } = (exports.lab = Lab.script());
const expect = Code.expect;

let sequelizeClientFactory = null;

describe('Helpers', () => {
    describe('SequelizeClientFactory', () => {
        beforeEach(async () => {
            sequelizeClientFactory = new SequelizeClientFactory();
        });

        describe('add', () => {
            it('should error when client configuration does not have a name', async () => {
                const clientConfiguration = {
                    config: {}
                };

                expect(() => sequelizeClientFactory.add(clientConfiguration)).to.throw(Error, '"name" is required');
            });

            it('should error when client configuration has a name not of type string', async () => {
                const clientConfiguration = {
                    name: new Date(),
                    config: {}
                };

                expect(() => sequelizeClientFactory.add(clientConfiguration)).to.throw(
                    Error,
                    '"name" must be a string'
                );
            });

            it('should error when client configuration does not have config', async () => {
                const clientConfiguration = {
                    name: 'foo'
                };

                expect(() => sequelizeClientFactory.add(clientConfiguration)).to.throw(Error, '"config" is required');
            });

            it('should error when client configuration has a config not of type object', async () => {
                const clientConfiguration = {
                    name: 'foo',
                    config: 'bar'
                };

                expect(() => sequelizeClientFactory.add(clientConfiguration)).to.throw(
                    Error,
                    '"config" must be of type object'
                );
            });

            it('should error when client configuration has an empty config', async () => {
                const clientConfiguration = {
                    name: 'foo',
                    config: {}
                };

                expect(() => sequelizeClientFactory.add(clientConfiguration)).to.throw(
                    Error,
                    '"config.dialect" is required'
                );
            });

            it('should not error when client configuration has a config with a dialect defined', async () => {
                const clientConfiguration = {
                    name: 'foo',
                    config: {
                        dialect: 'postgres'
                    }
                };

                expect(() => sequelizeClientFactory.add(clientConfiguration)).to.not.throw();
            });

            it('should error when a client configuration with the same name has already been built', async () => {
                const clientConfiguration = {
                    name: 'foo',
                    config: {
                        dialect: 'postgres'
                    }
                };

                expect(() => sequelizeClientFactory.add(clientConfiguration)).to.not.throw();
                expect(() => sequelizeClientFactory.add(clientConfiguration)).to.throw(
                    Error,
                    'A configuration with name of (foo) has already been added'
                );
            });
        });

        describe('count', () => {
            it('should initialize with 0', async () => {
                expect(sequelizeClientFactory.count()).to.equal(0);
            });

            it('should be 2 after 2 client configurations are added', async () => {
                sequelizeClientFactory.add({
                    name: 'client1',
                    config: {
                        dialect: 'postgres'
                    }
                });

                sequelizeClientFactory.add({
                    name: 'client2',
                    config: {
                        dialect: 'postgres'
                    }
                });

                expect(sequelizeClientFactory.count()).to.equal(2);
            });
        });

        describe('get', () => {
            it('should error when client configuration does not exist', async () => {
                expect(() => sequelizeClientFactory.build('foo')).to.throw(
                    Error,
                    'A configuration with name of (foo) does not exist'
                );
            });

            it('should fetch configuration when it exist', async () => {
                const clientConfiguration = {
                    name: 'client1',
                    config: {
                        dialect: 'postgres',
                        hello: 'world'
                    }
                };

                sequelizeClientFactory.add(clientConfiguration);

                let sut = undefined;
                expect(() => (sut = sequelizeClientFactory.get('client1'))).to.not.throw();
                expect(sut).to.exist().and.to.include(clientConfiguration.config);
            });
        });

        describe('build', () => {
            it('should error when client configuration does not exist', async () => {
                expect(() => sequelizeClientFactory.build('foo')).to.throw(
                    Error,
                    'A configuration with name of (foo) does not exist'
                );
            });

            it('should have built a client with config', async () => {
                const clientConfiguration = {
                    name: 'client1',
                    config: {
                        username: 'postgres',
                        password: 'postgres',
                        host: '127.0.0.1',
                        port: 5432,
                        pool: {
                            min: 0,
                            max: 5,
                            idle: 10000
                        },
                        dialect: 'postgres'
                    }
                };

                sequelizeClientFactory.add(clientConfiguration);

                let sut = undefined;
                const expectedConfig = Object.assign({}, clientConfiguration.config);
                delete expectedConfig.dialect;

                expect(() => (sut = sequelizeClientFactory.build('client1'))).to.not.throw();
                expect(sut).to.exist().and.to.be.an.instanceof(Sequelize);
                expect(sut.config).to.include(expectedConfig);
            });
        });
    });
});
