'use strict';

const Lab = require('@hapi/lab');
const Code = require('@hapi/code');
const { ShutdownTasks } = require('../../src/helpers');

const { before, after, beforeEach, afterEach, describe, it } = (exports.lab = Lab.script());
const expect = Code.expect;

let tasks = null;

describe('Helpers', () => {
    describe('ShutdownTasks', () => {
        beforeEach(async () => {
            tasks = new ShutdownTasks();
        });

        describe('register', () => {
            it('should error when task definition does not have a name', async () => {
                const task = {
                    asyncFunction: async () => {},
                    timeout: 1000
                };

                expect(() => tasks.register(task)).to.throw(Error, '"name" is required');
            });

            it('should error when tasks definition has a name not of type string', async () => {
                const task = {
                    name: new Date(),
                    asyncFunction: async () => {},
                    timeout: 1000
                };

                expect(() => tasks.register(task)).to.throw(Error, '"name" must be a string');
            });

            it('should error when tasks definition does not have an asyncFunction', async () => {
                const task = {
                    name: 'foo',
                    timeout: 1000
                };

                expect(() => tasks.register(task)).to.throw(Error, '"asyncFunction" is required');
            });

            it('should error when tasks definition has an asyncFunction not of type function', async () => {
                const task = {
                    name: 'foo',
                    asyncFunction: 'foo',
                    timeout: 1000
                };

                expect(() => tasks.register(task)).to.throw(Error, '"asyncFunction" must be of type function');
            });

            it('should error when tasks definition has a regular asyncFunction with parameter definition', async () => {
                const task = {
                    name: 'foo',
                    asyncFunction: (bar) => {},
                    timeout: 1000
                };

                expect(() => tasks.register(task)).to.throw(Error, '"asyncFunction" must have an arity of 0');
            });

            it('should error when tasks definition has an asynchronous asyncFunction with parameter definition', async () => {
                const task = {
                    name: 'foo',
                    asyncFunction: async (bar) => {},
                    timeout: 1000
                };

                expect(() => tasks.register(task)).to.throw(Error, '"asyncFunction" must have an arity of 0');
            });

            it('should error when tasks definition has a timeout not of type number', async () => {
                const task = {
                    name: 'foo',
                    asyncFunction: () => {},
                    timeout: 'bar'
                };

                expect(() => tasks.register(task)).to.throw(Error, '"timeout" must be a number');
            });

            it('should error when tasks definition has a timeout not of type integer', async () => {
                const task = {
                    name: 'foo',
                    asyncFunction: () => {},
                    timeout: 1000.1
                };

                expect(() => tasks.register(task)).to.throw(Error, '"timeout" must be an integer');
            });

            it('should error when a pre-existing task with the same name is registered', async () => {
                const task = {
                    name: 'foo',
                    asyncFunction: () => {},
                    timeout: 1000
                };

                expect(() => tasks.register(task)).to.not.throw();
                expect(() => tasks.register(task)).to.throw(
                    Error,
                    'A task with name of (foo) has already been defined'
                );
            });

            it('should accept task with synchronous function', async () => {
                const task = {
                    name: 'foo',
                    asyncFunction: () => {},
                    timeout: 1000
                };

                expect(() => tasks.register(task)).to.not.throw();
                expect(tasks._tasks.size).to.be.equal(1);
            });

            it('should accept task with asynchronous function', async () => {
                const task = {
                    name: 'foo',
                    asyncFunction: async () => {},
                    timeout: 1000
                };

                expect(() => tasks.register(task)).to.not.throw();
                expect(tasks._tasks.size).to.be.equal(1);
            });

            it('should accept task with no timeout provided', async () => {
                const task = {
                    name: 'foo',
                    asyncFunction: async () => {}
                };

                expect(() => tasks.register(task)).to.not.throw();
                expect(tasks._tasks.get('foo').timeout).to.be.equal(1000);
            });
        });

        describe('count', () => {
            it('should initialize with 0', async () => {
                expect(tasks.count()).to.equal(0);
            });

            it('should be 2 after 2 tasks are added', async () => {
                await tasks.register({
                    name: 'task1',
                    asyncFunction: () => {}
                });

                await tasks.register({
                    name: 'task2',
                    asyncFunction: () => {}
                });

                expect(tasks.count()).to.equal(2);
            });
        });

        describe('executeAll', () => {
            it('should execute synchronous tasks', async () => {
                await new Promise(async (resolve) => {
                    let counter = 0;

                    const resolver = () => {
                        if (++counter === 2) {
                            resolve();
                        }
                    };

                    const task1 = {
                        name: 'task1',
                        asyncFunction: resolver
                    };
                    const task2 = {
                        name: 'task2',
                        asyncFunction: resolver
                    };

                    tasks.register(task1);
                    tasks.register(task2);

                    await tasks.executeAll();
                });
            });

            it('should execute asynchronous tasks', async () => {
                await new Promise(async (resolve) => {
                    let counter = 0;

                    const resolver = async () => {
                        return new Promise((innerResolve) => {
                            setTimeout(() => {
                                if (++counter === 2) {
                                    resolve();
                                }

                                innerResolve();
                            }, 50);
                        });
                    };

                    const task1 = {
                        name: 'task1',
                        asyncFunction: resolver
                    };
                    const task2 = {
                        name: 'task2',
                        asyncFunction: resolver
                    };

                    tasks.register(task1);
                    tasks.register(task2);

                    await tasks.executeAll();
                });
            });

            it('should execute mixed synchronous/asynchronous tasks', async () => {
                await new Promise(async (resolve) => {
                    let counter = 0;

                    const asyncResolver = async () => {
                        return new Promise((innerResolve) => {
                            setTimeout(() => {
                                if (++counter === 2) {
                                    resolve();
                                }

                                innerResolve();
                            }, 50);
                        });
                    };

                    const syncResolver = () => {
                        if (++counter === 2) {
                            resolve();
                        }
                    };

                    const task1 = {
                        name: 'task1',
                        asyncFunction: asyncResolver
                    };
                    const task2 = {
                        name: 'task2',
                        asyncFunction: syncResolver
                    };

                    tasks.register(task1);
                    tasks.register(task2);

                    await tasks.executeAll();
                });
            });

            it('should enforce timeout when asynchronous tasks exceeds it', async () => {
                await new Promise(async (resolve) => {
                    let counter = 0;

                    const resolver = async () => {
                        return new Promise((innerResolve) => {
                            setTimeout(() => {
                                if (++counter === 2) {
                                    resolve();
                                }

                                innerResolve();
                            }, 200);
                        });
                    };

                    const task1 = {
                        name: 'task1',
                        asyncFunction: resolver,
                        timeout: 100
                    };
                    const task2 = {
                        name: 'task2',
                        asyncFunction: resolver,
                        timeout: 300
                    };

                    tasks.register(task1);
                    tasks.register(task2);

                    const [task1Result, task2Result] = await tasks.executeAll();

                    expect(task1Result.status).to.equal('rejected');
                    expect(task1Result.reason).to.be.an.error(Error, 'Timeout occurred');
                    expect(task2Result.status).to.equal('fulfilled');
                });
            });

            it('should not overlap invocation', async () => {
                let lock = false;
                let counter = 0;

                const sut = async () => {
                    tasks.register({
                        name: 'foo',
                        asyncFunction: () => {
                            if (!lock) {
                                ++counter;
                                lock = true;
                            } else {
                                throw new Error('race condition');
                            }

                            lock = false;
                        }
                    });

                    await Promise.all([tasks.executeAll(), tasks.executeAll()]);
                };

                await expect(sut()).to.not.reject();
                expect(counter).to.be.equal(1);
            });
        });
    });
});
