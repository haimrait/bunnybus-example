'use strict';

const Lab = require('@hapi/lab');
const Code = require('@hapi/code');
const { HealthProbes } = require('../../src/helpers');

const { before, after, beforeEach, afterEach, describe, it } = (exports.lab = Lab.script());
const expect = Code.expect;

let probes = null;

describe('Helpers', () => {
    describe('HealthProbes', () => {
        beforeEach(async () => {
            probes = new HealthProbes();
        });

        describe('register', () => {
            it('should error when probe definition does not have a name', async () => {
                const probe = {
                    asyncFunction: async () => {},
                    timeout: 1000
                };

                expect(() => probes.register(probe)).to.throw(Error, '"name" is required');
            });

            it('should error when probes definition has a name not of type string', async () => {
                const probe = {
                    name: new Date(),
                    asyncFunction: async () => {},
                    timeout: 1000
                };

                expect(() => probes.register(probe)).to.throw(Error, '"name" must be a string');
            });

            it('should error when probes definition does not have an asyncFunction', async () => {
                const probe = {
                    name: 'foo',
                    timeout: 1000
                };

                expect(() => probes.register(probe)).to.throw(Error, '"asyncFunction" is required');
            });

            it('should error when probes definition has an asyncFunction not of type function', async () => {
                const probe = {
                    name: 'foo',
                    asyncFunction: 'foo',
                    timeout: 1000
                };

                expect(() => probes.register(probe)).to.throw(Error, '"asyncFunction" must be of type function');
            });

            it('should error when probes definition has a regular asyncFunction with parameter definition', async () => {
                const probe = {
                    name: 'foo',
                    asyncFunction: (bar) => {},
                    timeout: 1000
                };

                expect(() => probes.register(probe)).to.throw(Error, '"asyncFunction" must have an arity of 0');
            });

            it('should error when probes definition has an asynchronous asyncFunction with parameter definition', async () => {
                const probe = {
                    name: 'foo',
                    asyncFunction: async (bar) => {},
                    timeout: 1000
                };

                expect(() => probes.register(probe)).to.throw(Error, '"asyncFunction" must have an arity of 0');
            });

            it('should error when probes definition has a timeout not of type number', async () => {
                const probe = {
                    name: 'foo',
                    asyncFunction: () => {},
                    timeout: 'bar'
                };

                expect(() => probes.register(probe)).to.throw(Error, '"timeout" must be a number');
            });

            it('should error when probes definition has a timeout not of type integer', async () => {
                const probe = {
                    name: 'foo',
                    asyncFunction: () => {},
                    timeout: 1000.1
                };

                expect(() => probes.register(probe)).to.throw(Error, '"timeout" must be an integer');
            });

            it('should error when a pre-existing probe with the same name is registered', async () => {
                const probe = {
                    name: 'foo',
                    asyncFunction: () => {},
                    timeout: 1000
                };

                expect(() => probes.register(probe)).to.not.throw();
                expect(() => probes.register(probe)).to.throw(
                    Error,
                    'A probe with name of (foo) has already been defined'
                );
            });

            it('should accept probe with synchronous function', async () => {
                const probe = {
                    name: 'foo',
                    asyncFunction: () => {},
                    timeout: 1000
                };

                expect(() => probes.register(probe)).to.not.throw();
                expect(probes._probes.size).to.be.equal(1);
            });

            it('should accept probe with asynchronous function', async () => {
                const probe = {
                    name: 'foo',
                    asyncFunction: async () => {},
                    timeout: 1000
                };

                expect(() => probes.register(probe)).to.not.throw();
                expect(probes._probes.size).to.be.equal(1);
            });

            it('should accept probe with no timeout provided', async () => {
                const probe = {
                    name: 'foo',
                    asyncFunction: async () => {}
                };

                expect(() => probes.register(probe)).to.not.throw();
                expect(probes._probes.get('foo').timeout).to.be.equal(2000);
            });
        });

        describe('count', () => {
            it('should initialize with 0', async () => {
                expect(probes.count()).to.equal(0);
            });

            it('should be 2 after 2 probes are added', async () => {
                await probes.register({
                    name: 'probe1',
                    asyncFunction: () => {}
                });

                await probes.register({
                    name: 'probe2',
                    asyncFunction: () => {}
                });

                expect(probes.count()).to.equal(2);
            });
        });

        describe('scanAll', () => {
            it('should execute synchronous tasks', async () => {
                const promise = new Promise(async (resolve) => {
                    let counter = 0;

                    const resolver = () => {
                        if (++counter === 2) {
                            resolve();
                        }
                    };

                    const probe1 = {
                        name: 'probe1',
                        asyncFunction: resolver
                    };
                    const probe2 = {
                        name: 'probe2',
                        asyncFunction: resolver
                    };

                    probes.register(probe1);
                    probes.register(probe2);
                });

                const {
                    ok,
                    probes: [probe1Res, probe2Res]
                } = await probes.scanAll();
                await promise;

                expect(ok).to.be.true();
                expect(probe1Res.name).to.equal('probe1');
                expect(probe1Res.error).to.not.exist();
                expect(probe2Res.name).to.equal('probe2');
                expect(probe2Res.error).to.not.exist();
            });

            it('should execute asynchronous probes', async () => {
                const promise = new Promise(async (resolve) => {
                    let counter = 0;

                    const resolver = async () => {
                        return new Promise((innerResolve) => {
                            setTimeout(() => {
                                if (++counter === 2) {
                                    resolve();
                                }

                                innerResolve();
                            }, 50);
                        });
                    };

                    const probe1 = {
                        name: 'probe1',
                        asyncFunction: resolver
                    };
                    const probe2 = {
                        name: 'probe2',
                        asyncFunction: resolver
                    };

                    probes.register(probe1);
                    probes.register(probe2);
                });

                const {
                    ok,
                    probes: [probe1Res, probe2Res]
                } = await probes.scanAll();
                await promise;

                expect(ok).to.be.true();
                expect(probe1Res.name).to.equal('probe1');
                expect(probe1Res.error).to.not.exist();
                expect(probe2Res.name).to.equal('probe2');
                expect(probe2Res.error).to.not.exist();
            });

            it('should execute mixed synchronous/asynchronous probes', async () => {
                const promise = new Promise(async (resolve) => {
                    let counter = 0;

                    const asyncResolver = async () => {
                        return new Promise((innerResolve) => {
                            setTimeout(() => {
                                if (++counter === 2) {
                                    resolve();
                                }

                                innerResolve();
                            }, 50);
                        });
                    };

                    const syncResolver = () => {
                        if (++counter === 2) {
                            resolve();
                        }
                    };

                    const probe1 = {
                        name: 'probe1',
                        asyncFunction: asyncResolver
                    };
                    const probe2 = {
                        name: 'probe2',
                        asyncFunction: syncResolver
                    };

                    probes.register(probe1);
                    probes.register(probe2);
                });

                const {
                    ok,
                    probes: [probe1Res, probe2Res]
                } = await probes.scanAll();
                await promise;

                expect(ok).to.be.true();
                expect(probe1Res.name).to.equal('probe1');
                expect(probe1Res.error).to.not.exist();
                expect(probe2Res.name).to.equal('probe2');
                expect(probe2Res.error).to.not.exist();
            });

            it('should enforce timeout when asynchronous probes exceeds it', async () => {
                const promise = new Promise(async (resolve) => {
                    let counter = 0;

                    const resolver = async () => {
                        return new Promise((innerResolve) => {
                            setTimeout(() => {
                                if (++counter === 2) {
                                    resolve();
                                }

                                innerResolve();
                            }, 200);
                        });
                    };

                    const probe1 = {
                        name: 'probe1',
                        asyncFunction: resolver,
                        timeout: 100
                    };
                    const probe2 = {
                        name: 'probe2',
                        asyncFunction: resolver,
                        timeout: 300
                    };

                    probes.register(probe1);
                    probes.register(probe2);
                });

                const {
                    ok,
                    probes: [probe1Res, probe2Res]
                } = await probes.scanAll();

                expect(ok).to.be.false();
                expect(probe1Res.name).to.equal('probe1');
                expect(probe1Res.error).to.exist().and.to.equal('Timeout occurred');
                expect(probe2Res.name).to.equal('probe2');
                expect(probe2Res.error).to.not.exist();
            });

            it('should return with ok === true when responses are defined without an ok property', async () => {
                const promise = new Promise(async (resolve) => {
                    let counter = 0;

                    const resolver = () => {
                        if (++counter === 2) {
                            resolve();
                        }

                        return {};
                    };

                    const probe1 = {
                        name: 'probe1',
                        asyncFunction: resolver
                    };
                    const probe2 = {
                        name: 'probe2',
                        asyncFunction: resolver
                    };

                    probes.register(probe1);
                    probes.register(probe2);
                });

                const {
                    ok,
                    probes: [probe1, probe2]
                } = await probes.scanAll();
                await promise;

                expect(ok).to.be.true();
                expect(probe1.name).to.equal('probe1');
                expect(probe1.response).to.be.an.object();
                expect(probe1.error).to.not.exist();
                expect(probe2.name).to.equal('probe2');
                expect(probe2.error).to.not.exist();
                expect(probe2.response).to.be.an.object();
            });

            it('should return with ok === false when onse probe is falsy', async () => {
                const promise = new Promise(async (resolve) => {
                    let counter = 0;

                    const resolver = () => {
                        if (++counter === 2) {
                            resolve();
                        }

                        return counter === 1 ? { ok: false } : { ok: true };
                    };

                    const probe1 = {
                        name: 'probe1',
                        asyncFunction: resolver
                    };
                    const probe2 = {
                        name: 'probe2',
                        asyncFunction: resolver
                    };

                    probes.register(probe1);
                    probes.register(probe2);
                });

                const {
                    ok,
                    probes: [probe1Res, probe2Res]
                } = await probes.scanAll();
                await promise;

                expect(ok).to.be.false();
                expect(probe1Res.name).to.equal('probe1');
                expect(probe1Res.response).to.be.an.object();
                expect(probe1Res.response.ok).to.be.false();
                expect(probe1Res.error).to.not.exist();
                expect(probe2Res.name).to.equal('probe2');
                expect(probe2Res.error).to.not.exist();
                expect(probe2Res.response).to.be.an.object();
                expect(probe2Res.response.ok).to.be.true();
            });
        });
    });
});
