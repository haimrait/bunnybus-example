'use strict';

const Lab = require('@hapi/lab');
const Code = require('@hapi/code');
const Redis = require('ioredis');
const { RedisClusterClientFactory } = require('../../src/helpers');

const { before, after, beforeEach, afterEach, describe, it } = (exports.lab = Lab.script());
const expect = Code.expect;

let redisClusterClientFactory = null;

describe('Helpers', () => {
    describe('RedisClusterClientFactory', () => {
        beforeEach(async () => {
            redisClusterClientFactory = new RedisClusterClientFactory();
        });

        describe('add', () => {
            it('should error when client configuration does not have a name', async () => {
                const clientConfiguration = {
                    config: {}
                };

                expect(() => redisClusterClientFactory.add(clientConfiguration)).to.throw(Error, '"name" is required');
            });

            it('should error when client configuration has a name not of type string', async () => {
                const clientConfiguration = {
                    name: new Date(),
                    config: {}
                };

                expect(() => redisClusterClientFactory.add(clientConfiguration)).to.throw(
                    Error,
                    '"name" must be a string'
                );
            });

            it('should not error when client configuration does not have config', async () => {
                const clientConfiguration = {
                    name: 'foo'
                };

                expect(() => redisClusterClientFactory.add(clientConfiguration)).to.not.throw();
            });

            it('should error when client configuration has a config not of type object', async () => {
                const clientConfiguration = {
                    name: 'foo',
                    config: 'bar'
                };

                expect(() => redisClusterClientFactory.add(clientConfiguration)).to.throw(
                    Error,
                    '"config" must be of type object'
                );
            });

            it('should error when client configuration has an empty config', async () => {
                const clientConfiguration = {
                    name: 'foo',
                    config: { anyProp: {} }
                };

                expect(() => redisClusterClientFactory.add(clientConfiguration)).to.throw(
                    Error,
                    '"config.anyProp" is not allowed'
                );
            });

            it('should error when client configuration has nodes that is not an array', async () => {
                const clientConfiguration = {
                    name: 'foo',
                    config: { nodes: {} }
                };

                expect(() => redisClusterClientFactory.add(clientConfiguration)).to.throw(
                    Error,
                    '"config.nodes" must be an array'
                );
            });

            it('should error when client configuration has nodes has items that is not an object', async () => {
                const clientConfiguration = {
                    name: 'foo',
                    config: { nodes: ['bleh'] }
                };

                expect(() => redisClusterClientFactory.add(clientConfiguration)).to.throw(
                    Error,
                    '"config.nodes[0]" must be of type object'
                );
            });

            it('should not error when client configuration has nodes with empty array', async () => {
                const clientConfiguration = {
                    name: 'foo',
                    config: { nodes: [] }
                };

                expect(() => redisClusterClientFactory.add(clientConfiguration)).to.not.throw();
            });

            it('should error when client configuration has options that is not an object', async () => {
                const clientConfiguration = {
                    name: 'foo',
                    config: { options: 'bleh' }
                };

                expect(() => redisClusterClientFactory.add(clientConfiguration)).to.throw(
                    Error,
                    '"config.options" must be of type object'
                );
            });

            it('should error when a client configuration with the same name has already been built', async () => {
                const clientConfiguration = {
                    name: 'foo'
                };

                expect(() => redisClusterClientFactory.add(clientConfiguration)).to.not.throw();
                expect(() => redisClusterClientFactory.add(clientConfiguration)).to.throw(
                    Error,
                    'A configuration with name of (foo) has already been added'
                );
            });
        });

        describe('count', () => {
            it('should initialize with 0', async () => {
                expect(redisClusterClientFactory.count()).to.equal(0);
            });

            it('should be 2 after 2 client configurations are added', async () => {
                redisClusterClientFactory.add({
                    name: 'client1'
                });

                redisClusterClientFactory.add({
                    name: 'client2'
                });

                expect(redisClusterClientFactory.count()).to.equal(2);
            });
        });

        describe('get', () => {
            it('should error when client configuration does not exist', async () => {
                expect(() => redisClusterClientFactory.build('foo')).to.throw(
                    Error,
                    'A configuration with name of (foo) does not exist'
                );
            });

            it('should fetch configuration when it exist', async () => {
                const clientConfiguration = {
                    name: 'client1',
                    config: {
                        nodes: [],
                        options: {
                            hello: 'world'
                        }
                    }
                };

                redisClusterClientFactory.add(clientConfiguration);

                let sut = undefined;
                expect(() => (sut = redisClusterClientFactory.get('client1'))).to.not.throw();
                expect(sut).to.exist().and.to.include(clientConfiguration.config);
            });
        });

        describe('build', () => {
            it('should error when client configuration does not exist', async () => {
                expect(() => redisClusterClientFactory.build('foo')).to.throw(
                    Error,
                    'A configuration with name of (foo) does not exist'
                );
            });

            it('should have built a client with empty config', async () => {
                redisClusterClientFactory.add({
                    name: 'client1'
                });

                let sut = undefined;
                expect(() => (sut = redisClusterClientFactory.build('client1'))).to.not.throw();
                expect(sut).to.exist().and.to.be.an.instanceof(Redis.Cluster);
                sut.quit();
            });

            it('should have built a client with config', async () => {
                const clientConfiguration = {
                    name: 'client1',
                    config: {
                        nodes: [],
                        options: {
                            maxRedirections: 1
                        }
                    }
                };

                redisClusterClientFactory.add(clientConfiguration);

                let sut = undefined;
                expect(() => (sut = redisClusterClientFactory.build('client1'))).to.not.throw();
                expect(sut).to.exist().and.to.be.an.instanceof(Redis.Cluster);
                expect(sut.options).to.include(clientConfiguration.config.options);
                sut.quit();
            });

            it('should have built a client with config and overrides', async () => {
                const clientConfiguration = {
                    name: 'client1',
                    config: {
                        nodes: [],
                        options: {
                            maxRedirections: 1
                        }
                    }
                };

                redisClusterClientFactory.add(clientConfiguration);

                const overrides = { dnsLookup: (address, callback) => callback(null, address) };

                let sut = undefined;
                expect(() => (sut = redisClusterClientFactory.build('client1', overrides))).to.not.throw();
                expect(sut).to.exist().and.to.be.an.instanceof(Redis.Cluster);
                expect(sut.options).to.include({ ...clientConfiguration.config.options, ...overrides });
                sut.quit();
            });
        });
    });
});
