'use strict';

const Lab = require('@hapi/lab');
const Code = require('@hapi/code');
const Pkg = require('../../package.json');
const Hapi = require('@hapi/hapi');
const Sinon = require('sinon');
const TestHarness = require('@tenna-llc/hapi-test-harness');
const Path = require('path');

const { before, after, beforeEach, afterEach, describe, it } = (exports.lab = Lab.script());
const expect = Code.expect;

let server = null;
let processExitSpy = null;

describe('Plugin', () => {
    describe('shutdownOrchestrator', () => {
        before(async () => {
            processExitSpy = Sinon.stub(process, 'exit');
            process.setMaxListeners(10000);
        });

        beforeEach(async () => {
            const serverBuilder = await new TestHarness.HapiServerBuilder(Hapi).withPluginUsingDirectoryPath(
                Path.join(__dirname, '..', '..')
            );

            server = await serverBuilder.build();

            await server.start();

            processExitSpy.resetHistory();
        });

        afterEach(async () => {
            return await server.stop();
        });

        describe('plugin registration', () => {
            it('should have exposed the "register" function', async () => {
                const sut = server.plugins[Pkg.name].shutdownOrchestrator.register;

                expect(sut).to.exist().and.to.be.a.function();
            });

            it('should have exposed the "count" function', async () => {
                const sut = server.plugins[Pkg.name].shutdownOrchestrator.count;

                expect(sut).to.exist().and.to.be.a.function();
            });
        });

        describe('task registration', () => {
            it('should be 1 when a task was added', async () => {
                const { register, count } = server.plugins[Pkg.name].shutdownOrchestrator;

                register({
                    name: 'foo',
                    asyncFunction: async () => {}
                });

                expect(count()).to.equal(1);
            });

            it('should have logged task being registered', async () => {
                const { register } = server.plugins[Pkg.name].shutdownOrchestrator;
                let logLevels = null;
                let logMessage = null;

                await new Promise((resolve) => {
                    server.events.once('log', (event, tags) => {
                        logLevels = tags;
                        logMessage = event.data;

                        resolve();
                    });

                    register({
                        name: 'foo',
                        asyncFunction: async () => {}
                    });
                });

                expect(logLevels).to.include('debug');
                expect(logMessage).to.equal('shutdown task (foo) registered');
            });
        });

        describe('task invocation', () => {
            describe('on Hapi.server.stop()', () => {
                it('should execute registered task', async () => {
                    const { register } = server.plugins[Pkg.name].shutdownOrchestrator;

                    const sut = new Promise(async (resolve) => {
                        register({
                            name: 'foo',
                            asyncFunction: async () => resolve()
                        });

                        server.stop();
                    });

                    await new Promise((resolve) => setTimeout(resolve, 50));

                    await expect(sut).to.not.reject();
                    await expect(processExitSpy.called).to.be.false();
                });

                it('should have logged server stop event', async () => {
                    const { register } = server.plugins[Pkg.name].shutdownOrchestrator;
                    let logLevels = null;
                    let logMessage = null;

                    const sut = new Promise(async (resolve) => {
                        register({
                            name: 'foo',
                            asyncFunction: async () => resolve()
                        });

                        server.events.once('log', (event, tags) => {
                            logLevels = tags;
                            logMessage = event.data;

                            resolve();
                        });

                        server.stop();
                    });

                    await new Promise((resolve) => setTimeout(resolve, 50));

                    await expect(sut).to.not.reject();
                    expect(logLevels).to.include('info');
                    expect(logMessage).to.equal('server shutdown detected, invoking all shutdown tasks');
                    await expect(processExitSpy.called).to.be.false();
                });
            });

            describe('on SIGTERM', () => {
                it('should execute registered task', async () => {
                    const { register } = server.plugins[Pkg.name].shutdownOrchestrator;

                    const sut = new Promise(async (resolve) => {
                        register({
                            name: 'foo',
                            asyncFunction: async () => resolve()
                        });

                        process.emit('SIGTERM');
                    });

                    await new Promise((resolve) => setTimeout(resolve, 50));

                    await expect(sut).to.not.reject();
                    await expect(processExitSpy.called).to.be.true();
                });

                it('should have logged SIGTERM event', async () => {
                    const { register } = server.plugins[Pkg.name].shutdownOrchestrator;
                    let logLevels = null;
                    let logMessage = null;

                    const sut = new Promise(async (resolve) => {
                        register({
                            name: 'foo',
                            asyncFunction: async () => resolve()
                        });

                        server.events.once('log', (event, tags) => {
                            logLevels = tags;
                            logMessage = event.data;

                            resolve();
                        });

                        process.emit('SIGTERM');
                    });

                    await new Promise((resolve) => setTimeout(resolve, 50));

                    await expect(sut).to.not.reject();
                    expect(logLevels).to.include('info');
                    expect(logMessage).to.equal('SIGTERM detected, invoking all shutdown tasks');
                    await expect(processExitSpy.called).to.be.true();
                });
            });

            describe('on SIGINT', () => {
                it('should execute registered task', async () => {
                    const { register } = server.plugins[Pkg.name].shutdownOrchestrator;

                    const sut = new Promise(async (resolve) => {
                        register({
                            name: 'foo',
                            asyncFunction: async () => resolve()
                        });

                        process.emit('SIGINT');
                    });

                    await new Promise((resolve) => setTimeout(resolve, 50));

                    await expect(sut).to.not.reject();
                    await expect(processExitSpy.called).to.be.true();
                });

                it('should have logged SIGINT event', async () => {
                    const { register } = server.plugins[Pkg.name].shutdownOrchestrator;
                    let logLevels = null;
                    let logMessage = null;

                    const sut = new Promise(async (resolve) => {
                        register({
                            name: 'foo',
                            asyncFunction: async () => resolve()
                        });

                        server.events.once('log', (event, tags) => {
                            logLevels = tags;
                            logMessage = event.data;

                            resolve();
                        });

                        process.emit('SIGINT');
                    });

                    await new Promise((resolve) => setTimeout(resolve, 50));

                    await expect(sut).to.not.reject();
                    expect(logLevels).to.include('info');
                    expect(logMessage).to.equal('SIGINT detected, invoking all shutdown tasks');
                    await expect(processExitSpy.called).to.be.true();
                });
            });
        });
    });
});
