'use strict';

const Lab = require('@hapi/lab');
const Code = require('@hapi/code');
const Hapi = require('@hapi/hapi');
const Pkg = require('../../package.json');
const Options = require('./mocks/options');
const TestHarness = require('@tenna-llc/hapi-test-harness');
const Path = require('path');

const { before, after, beforeEach, afterEach, describe, it } = (exports.lab = Lab.script());
const expect = Code.expect;

let server = null;

describe('Plugin', () => {
    describe('versionReporter', () => {
        before(async () => {
            process.setMaxListeners(10000);

            const serverBuilder = await new TestHarness.HapiServerBuilder(Hapi)
                .withPluginUsingDirectoryPath(Path.join(__dirname, '..', '..'))
                .withPluginOptionsUsingFilePath(Path.join(__dirname, 'mocks', 'options'));

            server = await serverBuilder.build();

            await server.start();
        });

        after(async () => {
            return await server.stop();
        });

        describe('endpoints', () => {
            describe('topLevelVersion', () => {
                let sut = null;

                before(async () => {
                    sut = await server.inject({
                        method: 'GET',
                        url: Options.paths.topLevelVersion
                    });
                });

                it('should return status of 200', async () => {
                    expect(sut.statusCode).to.equal(200);
                });

                it('should return a non empty response', async () => {
                    expect(sut.result).to.exist().and.be.an.object();
                });

                it('should return an object with a name property', async () => {
                    expect(sut.result.name).to.exist().and.to.be.a.string().and.to.equal(Pkg.name);
                });

                it('should return an object with a version property', async () => {
                    expect(sut.result.version).to.exist().and.to.be.a.string().and.to.equal(Pkg.version);
                });

                it('should return an object with a nodeVersion property', async () => {
                    expect(sut.result.nodeVersion).to.exist().and.to.be.a.string();
                });

                it('should return an object with dependency property', async () => {
                    expect(sut.result.dependencies).to.exist();
                });

                it('should return an object with peerDependencies property', async () => {
                    expect(sut.result.peerDependencies).to.exist();
                });

                it('should return a response header with content-type === application/json', async () => {
                    expect(sut.headers).to.contain({
                        'content-type': 'application/json; charset=utf-8'
                    });
                });
            });
        });
    });
});
