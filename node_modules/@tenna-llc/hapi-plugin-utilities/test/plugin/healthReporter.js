'use strict';

const Lab = require('@hapi/lab');
const Code = require('@hapi/code');
const Pkg = require('../../package.json');
const Hapi = require('@hapi/hapi');
const Options = require('./mocks/options');
const TestHarness = require('@tenna-llc/hapi-test-harness');
const Path = require('path');

const { before, after, beforeEach, afterEach, describe, it } = (exports.lab = Lab.script());
const expect = Code.expect;

let server = null;

describe('Plugin', () => {
    describe('healthReporter', () => {
        before(async () => {
            process.setMaxListeners(10000);
        });

        beforeEach(async () => {
            const serverBuilder = await new TestHarness.HapiServerBuilder(Hapi)
                .withPluginUsingDirectoryPath(Path.join(__dirname, '..', '..'))
                .withPluginOptionsUsingFilePath(Path.join(__dirname, 'mocks', 'options'));

            server = await serverBuilder.build();

            await server.start();
        });

        afterEach(async () => {
            return await server.stop();
        });

        describe('plugin registration', () => {
            it('should have exposed the "register" function', async () => {
                const sut = server.plugins[Pkg.name].healthReporter.register;

                expect(sut).to.exist().and.to.be.a.function();
            });

            it('should have exposed the "count" function', async () => {
                const sut = server.plugins[Pkg.name].healthReporter.count;

                expect(sut).to.exist().and.to.be.a.function();
            });
        });

        describe('probe registration', () => {
            it('should be 1 when a probe was added', async () => {
                const { register, count } = server.plugins[Pkg.name].healthReporter;

                register({
                    name: 'foo',
                    asyncFunction: async () => {}
                });

                expect(count()).to.equal(1);
            });

            it('should have logged probe being registered', async () => {
                const { register } = server.plugins[Pkg.name].healthReporter;
                let logLevels = null;
                let logMessage = null;

                await new Promise((resolve) => {
                    server.events.once('log', (event, tags) => {
                        logLevels = tags;
                        logMessage = event.data;

                        resolve();
                    });

                    register({
                        name: 'foo',
                        asyncFunction: async () => {}
                    });
                });

                expect(logLevels).to.include('debug');
                expect(logMessage).to.equal('health probe (foo) registered');
            });
        });

        describe('endpoints', () => {
            describe('health', () => {
                it('should return status of 200 when health is ok', async () => {
                    const sut = await server.inject({
                        method: 'GET',
                        url: Options.paths.health
                    });

                    expect(sut.statusCode).to.equal(200);
                    expect(sut.result).to.be.an.object().and.to.contain({
                        ok: true,
                        probes: []
                    });
                });

                it('should return status 500 when health is not ok', async () => {
                    const { register } = server.plugins[Pkg.name].healthReporter;

                    register({
                        name: 'foo',
                        asyncFunction: async () => {
                            return { ok: false };
                        }
                    });

                    const sut = await server.inject({
                        method: 'GET',
                        url: Options.paths.health
                    });

                    expect(sut.statusCode).to.equal(500);
                    expect(sut.result)
                        .to.be.an.object()
                        .and.to.contain({
                            ok: false,
                            probes: [
                                {
                                    name: 'foo',
                                    response: {
                                        ok: false
                                    }
                                }
                            ]
                        });
                });
            });
        });
    });
});
