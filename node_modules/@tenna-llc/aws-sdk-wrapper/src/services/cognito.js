'use strict';

const Crypto = require('crypto');
const Os = require('os');
const Ip = require('ip');
const AWS = require('aws-sdk');
const Service = require('./service');

const ATTRIBUTES = {
    EMAIL: 'email',
    EMAIL_VERIFIED: 'email_verified',
    PHONE: 'phone_number',
    PHONE_VERIFIED: 'phone_number_verified',
    USERID: 'custom:user_id',
    ACCOUNTID: 'custom:account_id',
    USERTYPE: 'custom:user_type'
};
const INVITE_PREFERENCE = {
    SUPPRESS: 'SUPPRESS',
    RESEND: 'RESEND'
};
const SIGNIN_PREFERENCE = {
    EMAIL: 'email',
    PHONE: 'phone'
};
const DELIVERY_METHOD = {
    EMAIL: 'EMAIL',
    PHONE: 'SMS'
};

class Cognito extends Service {
    constructor(params) {
        super(params);
        if (!(params && params.userPoolId)) {
            throw new UserPoolIdRequiredError();
        }

        Object.assign(this, { cognito: new AWS.CognitoIdentityServiceProvider(params), params });
    }

    /**
     * Creates user. One of email or phone needs to be provided
     * @param {Object} create user params object
     * @param {string} create.signInPreference Which email or phone will be used to sign in. Defaults to email
     * @param {string} create.email user email. Required if preferred sign in by email
     * @param {string} create.phone user phone. Required if preferred sign in by phone
     * @param {string} create.userId user id. Required
     * @param {string} create.accountId account id. Optional,
     * @param {string} create.userType user type. Optional
     * @param {bool} create.holdInvite hold invite. Optional. Defualts to false
     */
    async createUser({
        signInPreference = SIGNIN_PREFERENCE.EMAIL,
        email,
        phone,
        userId,
        accountId,
        userType,
        holdInvite = false
    }) {
        // validations
        if (signInPreference === SIGNIN_PREFERENCE.EMAIL && !email) throw new EmailRequriedError();
        if (signInPreference === SIGNIN_PREFERENCE.PHONE && !phone) throw new PhoneRequriedError();
        if (!userId) throw new UserIdRequiredError();

        // set usernme based on sign in preference
        let Username;
        let DesiredDeliveryMediums;
        if (signInPreference === SIGNIN_PREFERENCE.EMAIL) {
            Username = email;
            DesiredDeliveryMediums = [DELIVERY_METHOD.EMAIL];
        }

        if (signInPreference === SIGNIN_PREFERENCE.PHONE) {
            Username = phone;
            DesiredDeliveryMediums = [DELIVERY_METHOD.PHONE];
        }

        const UserAttributes = [
            ...(email
                ? [
                      { Name: ATTRIBUTES.EMAIL, Value: email },
                      { Name: ATTRIBUTES.EMAIL_VERIFIED, Value: 'true' }
                  ]
                : []),
            ...(phone
                ? [
                      { Name: ATTRIBUTES.PHONE, Value: phone },
                      { Name: ATTRIBUTES.PHONE_VERIFIED, Value: 'true' }
                  ]
                : []),
            { Name: ATTRIBUTES.USERID, Value: userId },
            ...(accountId ? [{ Name: ATTRIBUTES.ACCOUNTID, Value: accountId }] : []),
            ...(userType ? [{ Name: ATTRIBUTES.USERTYPE, Value: userType }] : [])
        ];

        return await this.cognito
            .adminCreateUser({
                UserPoolId: this.params.userPoolId,
                Username,
                UserAttributes,
                DesiredDeliveryMediums,
                ForceAliasCreation: true,
                ...(holdInvite ? { MessageAction: INVITE_PREFERENCE.SUPPRESS } : {})
            })
            .promise();
    }

    /**
     * Deletes a user
     * @param {Object} delete user params object
     * @param {string} delete.username username to be deleted. Required
     */
    async deleteUser({ username: Username }) {
        // validations
        if (!Username) throw new UsernameRequiredError();

        return await this.cognito.adminDeleteUser({ UserPoolId: this.params.userPoolId, Username }).promise();
    }

    /**
     * Enables/Disables a user
     * @param {Object} delete user params object
     * @param {string} delete.username username to be updated. Required
     * @param {bool} delete.enabled user status to set. Default true
     */
    async setUserStatus({ username: Username, enabled = true }) {
        // validations
        if (!Username) throw new UsernameRequiredError();

        return enabled
            ? await this.cognito.adminEnableUser({ UserPoolId: this.params.userPoolId, Username }).promise()
            : await this.cognito.adminDisableUser({ UserPoolId: this.params.userPoolId, Username }).promise();
    }

    /**
     * Updates user email or phone
     * @param {Object} update user params object
     * @param {string} update.username username to be updated. Required
     * @param {string} update.email user email. Optional if preferred sign in by email
     * @param {string} update.phone user phone. Optional if preferred sign in by phone
     * @param {string} update.userType user type. Optional
     */
    async updateUserAttributes({ username: Username, email, phone, userType }) {
        // validations
        if (!Username) throw new UsernameRequiredError();
        if (!(email || phone || userType)) throw new UserAttributesRequriedError();
        if (email && phone) throw new EmailOrPhoneRequriedError();

        const UserAttributes = [
            ...(email ? [{ Name: ATTRIBUTES.EMAIL, Value: email }] : []),
            ...(phone ? [{ Name: ATTRIBUTES.PHONE, Value: phone }] : []),
            ...(userType ? [{ Name: ATTRIBUTES.USERTYPE, Value: userType }] : [])
        ];

        return await this.cognito
            .adminUpdateUserAttributes({ UserPoolId: this.params.userPoolId, Username, UserAttributes })
            .promise();
    }

    /**
     * Deletes user atrributes
     * @param {string} delete.username username to be updated. Required
     * @param {string} delete.attributeNames array of strings valid values from Constants.Attributes. Required
     */
    async deleteUserAttributes({ username: Username, attributeNames: UserAttributeNames }) {
        // validations
        if (!Username) throw new UsernameRequiredError();
        const validAttributeNames = [ATTRIBUTES.USERTYPE];
        if (JSON.stringify(UserAttributeNames) !== JSON.stringify(validAttributeNames))
            throw new InvalidAttributeNameError();

        return await this.cognito
            .adminDeleteUserAttributes({
                UserPoolId: this.params.userPoolId,
                Username,
                UserAttributeNames
            })
            .promise();
    }

    /**
     * Gets user
     * @param {Object} get user params object
     * @param {string} get.username username to be updated. Required
     */
    async getUser({ username: Username }) {
        // validations
        if (!Username) throw new UsernameRequiredError();

        return await this.cognito.adminGetUser({ UserPoolId: this.params.userPoolId, Username }).promise();
    }

    /**
     * getTokensForUser
     * @param {Object} LoginContext the login information for a user against a user pool
     * @param {string} LoginContext.clientId The clientId of the User Pool
     * @param {string} LoginContext.clientSecret The client secret for the User Pool
     * @param {string} LoginContext.userName The username of the user
     * @param {string} LoginContext.password The password of the user
     */
    async getTokensForUser({ clientId: ClientId, clientSecret, userName: USERNAME, password: PASSWORD }) {
        // validations
        if (!ClientId) throw new ClientIdRequiredError();
        if (!USERNAME) throw new UsernameRequiredError();
        if (!PASSWORD) throw new PasswordRequiredError();

        return await this.cognito
            .adminInitiateAuth({
                AuthFlow: 'ADMIN_USER_PASSWORD_AUTH',
                ClientId,
                UserPoolId: this.params.userPoolId,
                AuthParameters: {
                    USERNAME,
                    PASSWORD,
                    ...(clientSecret
                        ? {
                              SECRET_HASH: Crypto.createHmac('SHA256', clientSecret)
                                  .update(USERNAME + ClientId)
                                  .digest('base64')
                          }
                        : {})
                },
                ContextData: {
                    HttpHeaders: [],
                    IpAddress: Ip.address(),
                    ServerName: Os.hostname(),
                    ServerPath: ''
                }
            })
            .promise();
    }

    /**
     * Set user password
     * @param {Object} setUserPassword user params object
     * @param {string} setUserPassword.username username to be updated. Required
     * @param {string} setUserPassword.password password to be set. Required
     * @param {bool} setUserPassword.permanent flag to determine if permanent or temporary. Optional. Defaults to true
     */
    async setUserPassword({ username: Username, password: Password, permanent: Permanent = true }) {
        // validations
        if (!Username) throw new UsernameRequiredError();
        if (!Password) throw new PasswordRequiredError();

        return await this.cognito
            .adminSetUserPassword({ UserPoolId: this.params.userPoolId, Username, Password, Permanent })
            .promise();
    }

    /**
     * Sends user invite
     * @param {Object} sendInvite user params object
     * @param {string} sendInvite.username username to send invite. Required
     */
    async sendInvite({ username: Username, signInPreference = SIGNIN_PREFERENCE.EMAIL }) {
        // validations
        if (!Username) throw new UsernameRequiredError();

        let DesiredDeliveryMediums;

        if (signInPreference === SIGNIN_PREFERENCE.EMAIL) {
            DesiredDeliveryMediums = [DELIVERY_METHOD.EMAIL];
        }

        if (signInPreference === SIGNIN_PREFERENCE.PHONE) {
            DesiredDeliveryMediums = [DELIVERY_METHOD.PHONE];
        }

        return await this.cognito
            .adminCreateUser({
                UserPoolId: this.params.userPoolId,
                Username,
                DesiredDeliveryMediums,
                MessageAction: INVITE_PREFERENCE.RESEND
            })
            .promise();
    }

    /**
     * Sends user invite
     * @param {Object} setMFA setMFA params object
     * @param {string} setMFA.username username to update. Required
     * @param {bool} setMFA.enabled MFA enabled/disabled. Required
     */
    async setMFA({ username: Username, enabled: Enabled }) {
        // validations
        if (!Username) throw new UsernameRequiredError();

        return await this.cognito
            .adminSetUserMFAPreference({
                UserPoolId: this.params.userPoolId,
                Username,
                // only SMS supported
                SMSMfaSettings: {
                    Enabled,
                    PreferredMfa: Enabled
                }
            })
            .promise();
    }
}

class UserPoolIdRequiredError extends Error {
    constructor() {
        super();
        this.name = this.constructor.name;
    }
}

class EmailRequriedError extends Error {
    constructor() {
        super();
        this.name = this.constructor.name;
    }
}

class PhoneRequriedError extends Error {
    constructor() {
        super();
        this.name = this.constructor.name;
    }
}

class EmailOrPhoneRequriedError extends Error {
    constructor() {
        super();
        this.name = this.constructor.name;
    }
}

class UserAttributesRequriedError extends Error {
    constructor() {
        super();
        this.name = this.constructor.name;
    }
}

class UserIdRequiredError extends Error {
    constructor() {
        super();
        this.name = this.constructor.name;
    }
}

class UsernameRequiredError extends Error {
    constructor() {
        super();
        this.name = this.constructor.name;
    }
}

class ClientIdRequiredError extends Error {
    constructor() {
        super();
        this.name = this.constructor.name;
    }
}

class PasswordRequiredError extends Error {
    constructor() {
        super();
        this.name = this.constructor.name;
    }
}

class InvalidAttributeNameError extends Error {
    constructor() {
        super();
        this.name = this.constructor.name;
    }
}

module.exports = Cognito;

module.exports.UserPoolIdRequiredError = UserPoolIdRequiredError;

module.exports.EmailRequriedError = EmailRequriedError;

module.exports.PhoneRequriedError = PhoneRequriedError;

module.exports.EmailOrPhoneRequriedError = EmailOrPhoneRequriedError;

module.exports.UserAttributesRequriedError = UserAttributesRequriedError;

module.exports.UserIdRequiredError = UserIdRequiredError;

module.exports.UsernameRequiredError = UsernameRequiredError;

module.exports.ClientIdRequiredError = ClientIdRequiredError;

module.exports.PasswordRequiredError = PasswordRequiredError;

module.exports.InvalidAttributeNameError = InvalidAttributeNameError;

module.exports.Constants = {
    ATTRIBUTES,
    INVITE_PREFERENCE,
    SIGNIN_PREFERENCE,
    DELIVERY_METHOD
};
