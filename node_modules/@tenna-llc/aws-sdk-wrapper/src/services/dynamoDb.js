'use strict';

const AWS = require('aws-sdk');
const Service = require('./service');
const { DYNAMODB_THROTTLED_ERROR } = require('../constants');

const Marshal = AWS.DynamoDB.Converter.marshall;
const Unmarshal = AWS.DynamoDB.Converter.unmarshall;
const AttributeConverter = AWS.DynamoDB.Converter.input;

let singleton = undefined;

class DynamoDB extends Service {
    constructor(params) {
        super(params);
        if (params) {
            this._params = params;
        }

        this._dynamoDBClient = new AWS.DynamoDB(this.params);

        return this;
    }

    static Singleton(params) {
        if (!singleton) {
            singleton = new DynamoDB();
        }

        if (params) {
            singleton.params = params;
        }

        return singleton;
    }

    get params() {
        return Object.assign({}, this._params);
    }

    set params(value) {
        this._params = Object.assign({}, value);
        this._dynamoDBClient = new AWS.DynamoDB(this.params);
    }

    async createTable(tableSchema) {
        const params = { TableName: tableSchema.TableName };

        const result = await this._dynamoDBClient.createTable(tableSchema).promise();
        await this._dynamoDBClient.waitFor('tableExists', params).promise();

        return result;
    }

    async deleteTable(tableName) {
        const params = { TableName: tableName };

        const result = await this._dynamoDBClient.deleteTable(params).promise();
        await this._dynamoDBClient.waitFor('tableNotExists', params).promise();

        return result;
    }

    async listTables() {
        const { TableNames } = await this._dynamoDBClient.listTables().promise();

        return TableNames;
    }

    async hasTable(tableName) {
        return (await this.listTables()).includes(tableName);
    }

    async putItem(tableName, item, params) {
        return await this.retryThrottled({
            action: 'putItem',
            params: { TableName: tableName, Item: Marshal(item), ...params }
        });
    }

    async getItemByKey(tableName, keyValue, params)
    {
        const { Item } = await this.retryThrottled({
            action: 'getItem',
            params: {
                TableName: tableName,
                Key: Marshal(keyValue),
                ...params
            }
        });

        return Item ? Unmarshal(Item) : null;
    }

    async deleteItemByKey(tableName, keyValue, params) {
        return await this.retryThrottled({
            action: 'deleteItem',
            params: { TableName: tableName, Key: Marshal(keyValue), ...params }
        });
    }

    async deleteAllRangeItemsByHash(tableName, hashName, rangeName, hashValue, queryParams, batchParams) {
        let counter = 0;
        // hard limit defined here
        // https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_BatchWriteItem.html
        const bulkActionLimit = 25;
        let deleteItems = [];

        const batchItems = ({ items, unprocessedItems }) => ({
            ...batchParams,
            RequestItems: {
                [tableName]: unprocessedItems || items.map((i) => ({ DeleteRequest: { Key: Marshal(i) } }))
            }
        });

        const batchDelete = async (items) => {
            let params = { ...items };
            let hasUnprocessedItems = false;
            do {
                // call delete
                const { UnprocessedItems: { [tableName]: unprocessedItems = [] } = {} } = await this.retryThrottled({
                    action: 'batchWriteItem',
                    params
                });

                // are there any failed ones
                hasUnprocessedItems = !!unprocessedItems.length;
                // retry unprocessed
                // exponential backoff is implemented in the Service base class
                hasUnprocessedItems && (params = batchItems({ unprocessedItems }));
            } while (hasUnprocessedItems);
        };

        for await (const item of this.queryWithHashKeyIterable(
            tableName,
            { [hashName]: hashValue },
            { ProjectionExpression: `${hashName}, ${rangeName}`, ...queryParams }
        )) {
            // push to items to delete
            deleteItems.push(item);

            if (deleteItems.length === bulkActionLimit) {
                await batchDelete(batchItems({ items: deleteItems }));

                // reset batch
                deleteItems = [];
                // increase item count
                counter += bulkActionLimit;
            }
        }

        // leftover items
        if (deleteItems.length) {
            await batchDelete(batchItems({ items: deleteItems }));
            // increase item count
            counter += deleteItems.length;
        }

        return counter;
    }

    async queryCountWithHashKey(tableName, keyValue, params) {
        const key = Object.keys(keyValue)[0];
        const value = keyValue[key];
        let count = 0;

        const { LastEvaluatedKey, Count } = await this.retryThrottled({
            action: 'query',
            params: {
                TableName: tableName,
                KeyConditionExpression: `${key} = :key`,
                ExpressionAttributeValues: { ':key': AttributeConverter(value) },
                Select: 'COUNT',
                ...params
            }
        });
        count = Count;

        if (LastEvaluatedKey) {
            const nextResult = await this.queryCountWithHashKey(tableName, keyValue, {
                ...params,
                ExclusiveStartKey: LastEvaluatedKey
            });

            count += nextResult;
        }

        return count;
    }

    async queryWithHashKey(tableName, keyValue, params) {
        const result = [];

        for await (const item of this.queryWithHashKeyIterable(tableName, keyValue, params)) {
            result.push(item);
        }

        return result;
    }

    async *queryWithHashKeyIterable(tableName, keyValue, params) {
        const key = Object.keys(keyValue)[0];
        const value = keyValue[key];

        for await (const item of this.queryIterable({
            TableName: tableName,
            KeyConditionExpression: `${key} = :key`,
            ExpressionAttributeValues: { ':key': AttributeConverter(value) },
            ...params
        })) {
            yield item;
        }
    }

    async *queryIndexWithHashKeyIterable(tableName, indexName, keyValue, params) {
        for await (const item of this.queryWithHashKeyIterable(tableName, keyValue, {
            IndexName: indexName,
            ...params
        })) {
            yield item;
        }
    }

    async queryWithHashKeyWithinRange(tableName, keyValue, rangeKey, startOfRange, endOfRange, params) {
        const result = [];

        for await (const item of this.queryWithHashKeyWithinRangeIterable(
            tableName,
            keyValue,
            rangeKey,
            startOfRange,
            endOfRange,
            params
        )) {
            result.push(item);
        }

        return result;
    }

    async *queryWithHashKeyWithinRangeIterable(tableName, keyValue, rangeKey, startOfRange, endOfRange, params) {
        const key = Object.keys(keyValue)[0];
        const value = keyValue[key];

        for await (const item of this.queryIterable({
            TableName: tableName,
            KeyConditionExpression: `${key} = :key AND ${rangeKey} BETWEEN :start AND :end`,
            ExpressionAttributeValues: {
                ':key': AttributeConverter(value),
                ':start': AttributeConverter(startOfRange),
                ':end': AttributeConverter(endOfRange)
            },
            ...params
        })) {
            yield item;
        }
    }

    async *queryIterable(params) {
        let ExclusiveStartKey;

        do {
            const { Items, LastEvaluatedKey } = await this.retryThrottled({
                action: 'query',
                params: {
                    ...params,
                    ...(ExclusiveStartKey ? { ExclusiveStartKey } : {})
                }
            });
            ExclusiveStartKey = LastEvaluatedKey;

            for (const item of Items) {
                yield Unmarshal(item);
            }
        } while (ExclusiveStartKey);
    }

    /**
     * retry mechanism for throttled requests
     * # of attempts and backoff handled by Service class
     * @param {*} param0
     * @returns
     */
    async retryThrottled({ action, params, retryCount = 0 }) {
        let mustRetry;

        do {
            try {
                mustRetry = false;
                return await this._dynamoDBClient[action](params).promise();
            } catch (error) {
                if (error.statusCode === 400 && error.code === DYNAMODB_THROTTLED_ERROR) {
                    mustRetry = true;
                    retryCount++;
                    this.logger &&
                        this.logger.log({
                            message: `retrying ${this.constructor.name}`,
                            action,
                            params,
                            retryCount
                        });
                } else throw error;
            }
        } while (mustRetry);
    }
}

module.exports = DynamoDB;
