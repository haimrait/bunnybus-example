# ingestion-pipeline-shared

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [Bootstrap](#bootstrap)
  - [`Consumers`](#consumers)
    - [Constructors](#constructors)
      - [`constructor({ bunnyBus })`](#constructor-bunnybus-)
    - [Methods](#methods)
      - [`withQueueSubscriptionOptions({ queueName, options })`](#withqueuesubscriptionoptions-queuename-options-)
      - [`setQueueHandler({ queueName, topic, handler })`](#setqueuehandler-queuename-topic-handler-)
      - [`async subscribeAll()`](#async-subscribeall)
      - [`async resubscribeAll()`](#async-resubscribeall)
      - [`async close()`](#async-close)
      - [`info({ lastProcessedThresholdMs = 10000})`](#info-lastprocessedthresholdms--10000)
- [Circuit Breaker](#circuit-breaker)
  - [`HttpCircuit`](#httpcircuit)
    - [Constructors](#constructors-1)
    - [`constructor({ consumers })`](#constructor-consumers-)
    - [Getter/Setters](#gettersetters)
      - [`breaker`](#breaker)
      - [`breakerOptions`](#breakeroptions)
      - [`logger`](#logger)
    - [Methods](#methods-1)
      - [`usingSuperAgent({ name, agent })`](#usingsuperagent-name-agent-)
      - [`withLogger({ logger })`](#withlogger-logger-)
      - [`withDefaultBreaker([{ breakerOptions }])`](#withdefaultbreaker-breakeroptions-)
      - [`withCustomBreaker({ asyncFunc[, breakerOptions ]})`](#withcustombreaker-asyncfunc-breakeroptions-)
      - [`activate()`](#activate)
- [Services](#services)
  - [DigestionApiClient](#digestionapiclient)
    - [Constructors](#constructors-2)
      - [`constructor({ superAgent, logger })`](#constructor-superagent-logger-)
    - [Methods](#methods-2)
      - [`async getTrackerMetaByMakeSerial({ make, serial })`](#async-gettrackermetabymakeserial-make-serial-)
      - [`async getTrackerMetaById({ trackerId })`](#async-gettrackermetabyid-trackerid-)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Bootstrap

### `Consumers`
A class that encapsulates the registration around RabbitMQ messaging.  This class layers on additional task like graceful disconnect and health reporting.  In addition, we can add additional layering such as security for AUTHN/AUTHX, throttling and so forth.

#### Constructors

##### `constructor({ bunnyBus })`
Creates an instance of `Consumers`.

```javascript
const bunnyBus = new BunnyBus();
const consumers = new Consumers({ bunnyBus });
```

#### Methods

##### `withQueueSubscriptionOptions({ queueName, options })`
Allows for configuration of a queue.  The option supplied here is proxied on to the `options` param of [`BunnyBus.subscribe(...)`](https://github.com/tenna-llc/bunnybus/blob/master/API.md#async-subscribequeue-handlers-options) interface.

```javascript
const bunnyBus = new BunnyBus();
const consumers = (new Consumers({ bunnyBus }))
    .withQueueSubscriptionOptions(
        { 
            queueName: 'queue1',
            options: { disableQueueBind: true }
        });
```

##### `setQueueHandler({ queueName, topic, handler })`
Add a message handler using the topic for queue routing.  Defintions for `topic` and `handler` and be found in the `handler` param of [`BunnyBus.subscribe(...)`](https://github.com/tenna-llc/bunnybus/blob/master/API.md#handler) interface.

```javascript
const bunnyBus = new BunnyBus();
const consumers = (new Consumers({ bunnyBus }))
    .setQueueHandler(
        { 
            queueName: 'queue1',
            topic: 'notification.#.created'
            handler: async ({ message, metaData, ack, rej, requeue }) => await ack()
        });
```

##### `async subscribeAll()`
Uses the optionality provided by the setup functions to call on `BunnyBus` to create the queues and add the handler subscription against those queues.

```javascript
const bunnyBus = new BunnyBus();
const consumers = (new Consumers({ bunnyBus }))
    .withQueueSubscriptionOptions(
        { 
            queueName: 'queue1',
            options: { disableQueueBind: true }
        })
    .setQueueHandler(
        { 
            queueName: 'queue1',
            topic: 'notification.#.created'
            handler: async ({ message, metaData, ack, rej, requeue }) => await ack()
        });

await consumers.subscribeAll();
```

##### `async resubscribeAll()`
Uses the optionality provided by the setup functions to rehydrate subscriptions on `BunnyBus`.  This should be called after [`close()`](#async-close).  This function is idempotent.


```javascript
const bunnyBus = new BunnyBus();
const consumers = (new Consumers({ bunnyBus }))
    .withQueueSubscriptionOptions(
        { 
            queueName: 'queue1',
            options: { disableQueueBind: true }
        })
    .setQueueHandler(
        { 
            queueName: 'queue1',
            topic: 'notification.#.created'
            handler: async ({ message, metaData, ack, rej, requeue }) => await ack()
        });

await consumers.subscribeAll();
// removes subscriptions
await consumers.close();
// rehydrates subscriptions
await consumer.resubscribeAll();
```

##### `async close()`
Provides the proper orchestration to unsubscribe handlers from queues they are listening to.  In addition, it attempts to allow existing in-flight messages to be processed.

##### `info({ lastProcessedThresholdMs = 10000})`
Returns a health report for all registered handlers.  An overall `ok` status of `true/false` is returned for the health of all handlers.

```json
# what is returned
{
    "ok": true,
    "bunnyBus": {
        "ok": true
    },
    "queues": [
        { 
            "name" : "queue1",
            "ok" : true,
            "unprocessedCount" : 100,
            "lastProcessed" : 1584288737885,
            "sinceLastProcessed" : 1043,
            "topics": [ {
                "name" : "notification.#.created",
                "windowedExecutionTimes" : [ 45203, 43435, 34353, 535655 ],
                "averageExecutionTime" : 256904,
                "lastProcessed" : 1584288737885,
                "sinceLastProcessed" : 1043
            }]
        }
    ]
}
```


## Circuit Breaker

### `HttpCircuit`
A class that abstracts the manual manipulation of circuit breaker hook ups to your http client.

#### Constructors

#### `constructor({ consumers })`
Creats an instance of `HttpCircuit`.

```javascript
const bunnyBus = new BunnyBus();
const consumers = new Consumers({ bunnyBus });
const circuit = new HttpCircuit({ consumers });
```

#### Getter/Setters

##### `breaker`
Returns a breaker that has been applied.  Returns `undefined` until `withDefaultBreaker` or `withCustomBreaker` has been configured.

##### `breakerOptions`
Returns the breaker options that were supplied.

##### `logger`
Returns a logger. Returns a NoOp logger until `withLogger` has been configured.

#### Methods

##### `usingSuperAgent({ name, agent })`
Configure a `superagent` agent to be spied on.  The agent has to be of type `ProxyAgent` from the `@tenna-llc/superagent-wrapper` package.

```javascript
const { ProxyAgent } = require('@tenna-llc/superagent-wrapper');

new HttpCircuit({ consumers }).withSuperAgent({ name: 'be-crud', agent: new ProxyAgent() });
```

##### `withLogger({ logger })`
Configure a `logger` to be used with the instance.  The logger needs to have a contract of `info(data)`, `debug(data)`, `error(data)`.  The `@tenna-llc/hapi-log-wrapper` package will satisfy this requirement.

```javascript
const Hapi = require('@hapi/hapi');
const LoggerFactory = require('@tenna-llc/hapi-log-wrapper');

const server = new Hapi.Server();

const logger = new LoggerFactory()
  .withHapiServer(server)
  .build();

new HttpCircuit({ consumers }).withLogger({ logger });
```

##### `withDefaultBreaker([{ breakerOptions }])`
Configure this circuit with a default `opossum` circuit breaker.  Uses the following `opossum` configuration.  Circuit will allow for 1% of error before transitioning to open state.  It will reset after 30 seconds.  Trip condition includes all 4xx and 5xx HTTP response codes.  Request client timeout set through `ProxyAgent` will also trip.

```json
const breakerOptions = {
    "timeout": 2000,
    "errorThresholdPercentage": 1,
    "resetTimeout": 30000
}
```

##### `withCustomBreaker({ asyncFunc[, breakerOptions ]})`
Configure this circuit with your custom trip breaker logic.

* `asyncFunc` - A function that accepts two parameters (`error`, `response`).  `error` will be passed when the request client events an error.  This could be any non 200 series response or request client internal errors.  `response` will be passed when the request was successfully executed, usually signalling a 2xx series response.  This function is required to return a `Promise`.  To trip the breaker, this function needs to call `reject`.

**Examples**

When a 500 level error is caught and passed through the custom function, and we want to cause the circuit breaker to see failure.  All other errors will be proxied through without tripping the breaker.

```javascript
const asyncFunc = (err, response) => {
    return new Promise((resolve, reject) => {
        (err.status === 500)
            ? reject(err);
            : resolve(err);
    });
}
```

When a 200 response is returned and we don't want to trip the breaker.

```javascript
const asyncFunc = (err, response) => {
    return new Promise((resolve, reject) => {
        (!err && response.status === 200)
            ? resolve(response);
            : resolve(err || response);
    });
}
```

When a 200 response is returned, but we want to trip when body contains `ok === false`.

```javascript
const asyncFunc = (err, response) => {
    return new Promise((resolve, reject) => {
        (responase && response.body && !response.body.ok)
            ? reject(response)
            : resolve(response || err);
    });
}
```

##### `activate()`
Applies all breaker configuration and enables the circuit.

```javascript
const agent = new ProxyAgent();
new HttpCircuit(...).usingSuperAgent({ name: 'be-crud', agent }).withDefaultBreaker().activate();

//this will not be monitored by the circuit.
await agent.get('google.com/api');
```

## Services

### DigestionApiClient
Wraps Digestion API calls

#### Constructors

##### `constructor({ superAgent, logger })`
Creats an instance of `DigestionApiClient`.

```javascript
const LoggerFactory = require('@tenna-llc/hapi-log-wrapper');
const logger = new LoggerFactory().build();

// using @tenna-llc/hapi-plugin-utilities
const superAgent = server.plugins[HAPI_UTILITIES].superAgentClientFactory.build(this.options.digestionApiKey);


const client = new DigestionApiClient({ superAgent, logger });
```

#### Methods

##### `async getTrackerMetaByMakeSerial({ make, serial })`
Gets tracker meta by make and serial

```javascript
await client.getTrackerMetaByMakeSerial({ make:'DLT', serial:'123' });
```

##### `async getTrackerMetaById({ trackerId })`
Gets tracker meta by id

```javascript
await client.getTrackerMetaById({ trackerId:'uuid' });
```
