'use strict';

const CircuitBreaker = require('opossum');
const { ProxyAgent } = require('@tenna-llc/superagent-wrapper');
const { Consumers } = require('../bootstrap');
const Joi = require('@hapi/joi');
const { HttpCircuitError } = require('../exceptions');

const schema = {
    constructor: Joi.object({
        consumers: Joi.object().instance(Consumers).required()
    })
        .label('params')
        .required(),
    usingSuperAgent: Joi.object({
        name: Joi.string().required(),
        agent: Joi.object().instance(ProxyAgent).required()
    })
        .label('params')
        .required(),
    withLogger: Joi.object({
        debug: Joi.function().required(),
        info: Joi.function().required(),
        error: Joi.function().required()
    })
        .unknown(true)
        .label('logger')
        .required(),
    withDefaultBreaker: Joi.object({
        breakerOptions: Joi.object().optional()
    })
        .label('params')
        .optional(),
    withCustomBreaker: Joi.object({
        breakerOptions: Joi.object().optional(),
        asyncFunc: Joi.function().arity(2).required()
    })
        .label('params')
        .required()
};

class HttpCircuit {
    constructor(params) {
        const { error, value: { consumers } = {} } = schema.constructor.validate(params);

        if (error) {
            throw error;
        }

        this._consumers = consumers;
        this._agents = new Map();
        this._breakerOptions = HttpCircuit.DEFAULT_BREAKER_OPTIONS;
        this._breaker = undefined;
        this._logger = {
            debug: () => {},
            info: () => {},
            error: () => {}
        };
        this._rejectionHandler = (err, reject) => reject(err);
        this._resolutionHandler = (response, resolve) => resolve(response);

        return this;
    }

    static get DEFAULT_BREAKER_OPTIONS() {
        return {
            timeout: 2000,
            errorThresholdPercentage: 1,
            resetTimeout: 30000
        };
    }

    get breakerOptions() {
        return this._breakerOptions;
    }

    get breaker() {
        return this._breaker;
    }

    get logger() {
        return this._logger;
    }

    usingSuperAgent(params) {
        const { error, value: { name, agent } = {} } = schema.usingSuperAgent.validate(params);

        if (error) {
            throw error;
        }

        this._agents.set(name, agent);

        return this;
    }

    withLogger(logger) {
        const { error } = schema.withLogger.validate(logger);

        if (error) {
            throw error;
        }

        this._logger = logger;

        return this;
    }

    withDefaultBreaker(params) {
        const { error, value: { breakerOptions } = {} } = schema.withDefaultBreaker.validate(params);

        if (error) {
            throw error;
        }

        return this.withCustomBreaker({
            breakerOptions: { ...HttpCircuit.DEFAULT_BREAKER_OPTIONS, ...breakerOptions },
            asyncFunc: (err, response) => {
                return new Promise((resolve, reject) => {
                    (err && err.status >= 400 && err.status <= 599) || (err && err.errno === 'ETIMEDOUT')
                        ? reject(err)
                        : resolve(err || response);
                });
            }
        });
    }

    withCustomBreaker(params) {
        const { error, value: { asyncFunc, breakerOptions } = {} } = schema.withCustomBreaker.validate(params);

        if (error) {
            throw error;
        }

        this._breaker = new CircuitBreaker(asyncFunc, breakerOptions);

        this._breakerOptions = breakerOptions;

        this._breaker.on('open', () => {
            this.logger.error('HTTP circuit opened');
            this._consumers.close();
        });

        this._breaker.on('halfOpen', () => {
            this.logger.info('HTTP circuit half opened');
            this._consumers.resubscribeAll();
        });

        this._breaker.on('close', () => {
            this.logger.info('HTTP circuit closed');
        });

        this._rejectionHandler = (err, reject) => {
            this._breaker
                .fire(err)
                .then((uncaughtError) => reject(uncaughtError))
                .catch((breachedError) => reject(new HttpCircuitError(breachedError)));
        };

        this._resolutionHandler = (response, resolve) => {
            this._breaker.fire(null, response).then(resolve);
        };

        return this;
    }

    activate() {
        for (const [name, agent] of this._agents) {
            this.logger.debug(`Attaching circuit breaker for (${name})`);
            agent.rejectionMiddleware = this._rejectionHandler;
            agent.resolutionMiddleware = this._resolutionHandler;
        }
    }
}

module.exports = HttpCircuit;
