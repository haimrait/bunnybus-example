'use strict';

const BunnyBus = require('@tenna-llc/bunnybus');
const Joi = require('@hapi/joi');
const HealthSummary = require('./healthSummary');

const schema = {
    constructor: Joi.object({
        bunnyBus: Joi.object().instance(BunnyBus).required()
    })
        .label('params')
        .required(),
    withQueueSubscriptionOptions: Joi.object({
        queueName: Joi.string().required(),
        options: Joi.object().required()
    })
        .label('params')
        .required(),
    setQueueHandler: Joi.object({
        queueName: Joi.string().required(),
        topic: Joi.string().required(),
        handler: Joi.function().required()
    })
        .label('params')
        .required()
};

class Consumers {
    constructor(params) {
        const { error, value: { bunnyBus } = {} } = schema.constructor.validate(params);

        if (error) {
            throw error;
        }

        this._bunnyBus = bunnyBus;
        this._queueOptions = new Map();
        this._queueHandlers = new Map();
        this._queueStates = new Map();
        this._isRunning = true;

        return this;
    }

    withQueueSubscriptionOptions(params) {
        const { error, value: { queueName, options } = {} } = schema.withQueueSubscriptionOptions.validate(params);

        if (error) {
            throw error;
        }

        this._queueOptions.set(queueName, options);

        return this;
    }

    setQueueHandler(params) {
        const { error, value: { queueName, topic, handler } = {} } = schema.setQueueHandler.validate(params);

        if (error) {
            throw error;
        }

        const topicHandlers = !this._queueHandlers.has(queueName)
            ? this._queueHandlers.set(queueName, new Map()).get(queueName)
            : this._queueHandlers.get(queueName);

        topicHandlers.set(topic, handler);

        if (!this._queueStates.has(queueName)) {
            this._queueStates.set(queueName, {
                inFlightMessagesCount: 0,
                topicsLastProcessed: {},
                topicsWindowedExecutionTimes: {}
            });
        }

        return this;
    }

    async subscribeAll() {
        const self = this;

        for (const [queueName, topicHandlers] of this._queueHandlers) {
            const handlers = {};

            for (const [topic, handler] of topicHandlers) {
                handlers[topic] = async (...args) => {
                    const queueState = self._queueStates.get(queueName);

                    if (!queueState.topicsWindowedExecutionTimes[topic]) {
                        queueState.topicsWindowedExecutionTimes[topic] = [];
                    }

                    if (self._isRunning) {
                        ++queueState.inFlightMessagesCount;
                        const startTime = Date.now();
                        await handler(...args);
                        --queueState.inFlightMessagesCount;
                        const endTime = Date.now();
                        queueState.topicsLastProcessed[topic] = endTime;
                        queueState.topicsWindowedExecutionTimes[topic].push(endTime - startTime);

                        if (queueState.topicsWindowedExecutionTimes[topic].length > 100) {
                            queueState.topicsWindowedExecutionTimes[topic].shift();
                        }
                    }

                    // We want this to detach from a queue immediately after processing
                    if (!self._isRunning && queueState.inFlightMessagesCount === 0) {
                        await self._bunnyBus.unsubscribe({ queue: queueName });
                    }
                };
            }

            await this._bunnyBus.subscribe({ queue: queueName, handlers, options: this._queueOptions.get(queueName) });
        }
    }

    async info({ lastProcessedThresholdMs = 10000 } = {}) {
        const summary = new HealthSummary({ lastProcessedThresholdMs });

        const checkQueuePromises = [];

        for (const [queueName] of this._queueHandlers) {
            checkQueuePromises.push(this._bunnyBus.checkQueue({ name: queueName }));
        }

        const queueStats = await Promise.all(checkQueuePromises);

        for (const queueStat of queueStats) {
            summary.getQueue(queueStat.queue).unprocessedCount = queueStat.messageCount;
        }

        for (const [queueName, { topicsLastProcessed, topicsWindowedExecutionTimes }] of this._queueStates) {
            const queueStat = summary.getQueue(queueName);

            for (const [topic, endTime] of Object.entries(topicsLastProcessed)) {
                queueStat.getTopic(topic).lastProcessed = endTime;
            }

            for (const [topic, windowedExecutionTimes] of Object.entries(topicsWindowedExecutionTimes)) {
                queueStat.getTopic(topic).windowedExecutionTimes = windowedExecutionTimes;
            }
        }

        return summary.toPOCO();
    }

    async resubscribeAll() {
        this._isRunning = true;

        const promises = [];

        for (const [queueName] of this._queueHandlers) {
            promises.push(this._bunnyBus.resubscribe({ queue: queueName }));
        }

        await Promise.all(promises);
    }

    async close() {
        this._isRunning = false;

        const promises = [];

        for (const [queueName, { inFlightMessagesCount }] of this._queueStates) {
            if (inFlightMessagesCount === 0) {
                promises.push(this._bunnyBus.unsubscribe({ queue: queueName }));
            }
        }

        await Promise.all(promises);
    }
}

module.exports = Consumers;
