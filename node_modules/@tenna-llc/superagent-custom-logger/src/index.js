'use strict';

const NS_PER_SEC = 1e9;
const MS_PER_NS = 1e6;

const routeLogger = (logger, response) => {
    const logItem = {};
    logItem.statusCode = response.statusCode;
    logItem.method = response.request.method;
    logItem.url = response.request.url;

    if (response.ok) {
        logger.debug(logItem);
    } else if (logItem.statusCode === 404) {
        // we might want to change this to all 4xx errors
        logger.warn(logItem);
    } else {
        logger.error(logItem);
    }
};

const timingLogger = (url, logger, request) => {
    const eventTimes = {
        startAt: process.hrtime(),
        socketAssigned: undefined,
        dnsLookupAt: undefined,
        tcpConnectionAt: undefined,
        tlsHandshakeAt: undefined,
        firstByteAt: undefined,
        endAt: undefined
    };

    request
        .on('socket', (socket) => {
            eventTimes.socketAssigned = process.hrtime();
            socket
                .on('lookup', () => {
                    eventTimes.dnsLookupAt = process.hrtime();
                })
                .on('connect', () => {
                    eventTimes.tcpConnectionAt = process.hrtime();
                })
                .on('secureConnect', () => {
                    eventTimes.tlsHandshakeAt = process.hrtime();
                })
                .on('timeout', () => {
                    const err = new Error(`ETIMEDOUT for req.url: ${url}`);
                    err.code = `ETIMEDOUT`;
                    logger.error(err);
                });
        })
        .on('response', (res) => {
            res.once('readable', () => {
                eventTimes.firstByteAt = process.hrtime();
            }).on('end', () => {
                eventTimes.endAt = process.hrtime();
                logger.debug({ url, statusCode: res.statusCode, timings: getTimings(eventTimes) });
            });

            (function consumeStreamSoEndEventAlwaysFire() {
                res.on('data', () => {});
            })();
        });
};

const getTimings = (eventTimes) => {
    return {
        socketAssigned: getHrTimeDurationInMs(eventTimes.startAt, eventTimes.socketAssigned),
        dnsLookup: getHrTimeDurationInMs(eventTimes.socketAssigned, eventTimes.dnsLookupAt),
        tcpConnection: getHrTimeDurationInMs(
            eventTimes.dnsLookupAt || eventTimes.socketAssigned,
            eventTimes.tcpConnectionAt
        ),
        tlsHandshake: getHrTimeDurationInMs(eventTimes.tcpConnectionAt, eventTimes.tlsHandshakeAt),

        firstByte: getHrTimeDurationInMs(
            eventTimes.tlsHandshakeAt || eventTimes.tcpConnectionAt,
            eventTimes.firstByteAt
        ),
        contentTransfer: getHrTimeDurationInMs(eventTimes.firstByteAt, eventTimes.endAt),
        total: getHrTimeDurationInMs(eventTimes.startAt, eventTimes.endAt)
    };
};

const getHrTimeDurationInMs = (startTime, endTime) => {
    if (!startTime || !endTime) return undefined;

    const secondDiff = endTime[0] - startTime[0];
    const nanoSecondDiff = endTime[1] - startTime[1];
    const diffInNanoSecond = secondDiff * NS_PER_SEC + nanoSecondDiff;

    return diffInNanoSecond / MS_PER_NS;
};

const Plugin = (logger) => {
    return (agent) => {
        agent
            .on('request', ({ req: request }) => timingLogger(agent.url, logger, request))
            .on('response', (response) => routeLogger(logger, response));
    };
};

module.exports = Plugin;
