"use strict";

function _interopDefault(e) {
    return e && "object" == typeof e && "default" in e ? e.default : e;
}

var e = _interopDefault(require("async_hooks")), t = _interopDefault(require("epsagon")), r = _interopDefault(require("semver")), n = _interopDefault(require("node-schedule")), a = _interopDefault(require("uuid4")), s = _interopDefault(require("shimmer"));

const {eventInterface: o, tracer: i, utils: c} = t, u = !r.satisfies(process.version, "^8.13 || >=10.14.2");

let d = !0, l = {};

const p = new WeakMap;

function destroyAsync(e) {
    if (l[e] && l[e].mainAsyncIds.has(e)) {
        const t = l[e];
        t.relatedAsyncIds.forEach(e => {
            delete l[e];
        }), t.relatedAsyncIds.clear(), t.mainAsyncIds.clear();
    }
}

function initAsync(e, t, r, n) {
    l[r] && (l[e] = l[r], l[e].relatedAsyncIds.add(e)), !u || "TCPWRAP" !== t && "HTTPPARSER" !== t || (destroyAsync(p.get(n)), 
    p.set(n, e));
}

function get() {
    return l[e.executionAsyncId()] || null;
}

var g = {
    get: get,
    init: function() {
        e.createHook({
            init: initAsync,
            destroy: destroyAsync,
            promiseResolve: destroyAsync
        }).enable(), i.getTrace = get;
    },
    setAsyncReference: function(t) {
        if (!t) return;
        const r = e.executionAsyncId();
        l[r] = t, l[r].relatedAsyncIds.add(r);
    },
    destroyAsync: destroyAsync,
    RunInContext: function(t, r) {
        const n = t();
        return null != n && (n.relatedAsyncIds = new Set, n.mainAsyncIds = new Set, l[e.executionAsyncId()] = n), 
        r();
    },
    privateClearTracers: function(e) {
        Object.keys(l).length > e && (c.debugLog(`[resource-monitor] found ${Object.keys(l).length}, deleting`), 
        Object.values(l).forEach(e => {
            e.currRunner && o.addToMetadata(e.currRunner, {
                instrum_cleared_hourly: !0
            });
        }), l = {});
    },
    privateCheckTTLConditions: function(e) {
        const t = [ ...new Set(Object.values(l)) ].filter(t => e(t));
        t.length && (c.debugLog(`[resource-monitor] found ${t.length} tracers to remove`), 
        c.debugLog("[resource-monitor] tracers before delete: " + Object.values(l).length), 
        t.forEach(e => {
            e.currRunner && o.addToMetadata(e.currRunner, {
                instrum_cleared_ttl: !0
            }), e.relatedAsyncIds.forEach(e => {
                delete l[e];
            });
        }), c.debugLog("[resource-monitor] tracers after delete: " + Object.values(l).length));
    },
    disableTracing: function() {
        d = !1;
    },
    isTracingEnabled: function() {
        return d;
    },
    setMainReference: function(t = !0) {
        const r = e.executionAsyncId();
        l[r] && (t ? l[r].mainAsyncIds.add(r) : l[r].mainAsyncIds.delete(r));
    }
};

const h = parseInt(process.env.EPSAGON_RESOURCE_MAX_TRACERS || "50", 10), f = parseInt(process.env.EPSAGON_RESOURCE_MAX_TRACER_TTL || "300", 10), m = process.env.EPSAGON_RESOURCE_TTL_CHECK_CRON || "*/5 * * * *", b = process.env.EPSAGON_RESOURCE_CLEAR_TRACERS_CRON || "0 * * * *";

n.scheduleJob("checkTTL", m, (function() {
    g.privateCheckTTLConditions((function(e) {
        return !(!e || !e.createdAt) && (Date.now() - e.createdAt) / 1e3 > f;
    }));
})), n.scheduleJob("clearTracers", b, (function() {
    g.privateClearTracers(h);
}));

let y = [];

const E = {
    "user-agent": "elb-healthchecker/2.0"
}, v = [ "txt", "html", "jpg", "png", "css", "js", "jsx", "woff", "woff2", "ttf", "eot", "ico" ];

var T = {
    ignoreEndpoints: function(e) {
        y = e;
    },
    ignoredEndpoints: function() {
        return y;
    },
    extractEpsagonHeader: function(e) {
        return e && e["epsagon-trace-id"];
    },
    EPSAGON_HEADER: "epsagon-trace-id",
    shouldIgnore: function(e, t) {
        let r = !1;
        return t && (r = Object.keys(E).map(e => {
            const r = Object.keys(t).find(t => t.toLowerCase() === e);
            return r && t[r].toLowerCase() === E[e];
        }).includes(!0)), !!v.includes(e.split(".").pop()) || (y.filter(t => e.startsWith(t)).length > 0 || r);
    }
};

const {utils: R, eventInterface: _, event: q, errorCode: x} = t, {extractEpsagonHeader: L} = T;

var C = {
    createRunner: function(e, t) {
        const r = new q.Event([ "hapi-" + a(), R.createTimestampFromTime(t), null, "runner", 0, x.ErrorCode.OK ]), n = new q.Resource([ e.url.host, "hapi", e.method ]);
        return r.setResource(n), _.createTraceIdMetadata(r), r;
    },
    finishRunner: function(e, t, r, n) {
        e.setDuration(R.createDurationTimestamp(n)), _.addToMetadata(e, {
            url: t.url.href,
            route: t.route.path,
            query: t.url.search,
            status_code: r.statusCode
        }, {
            request_headers: t.headers,
            params: t.params,
            response_headers: r.headers
        }), L(t.headers) && _.addToMetadata(e, {
            http_trace_id: L(t.headers)
        }), r.statusCode >= 500 && e.setErrorCode(x.ErrorCode.EXCEPTION);
    }
};

const {tracer: M, utils: A, eventInterface: w, moduleUtils: I} = t, {shouldIgnore: k} = T, W = [ "hapi-swagger", "hapi-pino", "@hapi/inert", "@hapi/vision" ];

function handleResponse(e, t, r, n, a) {
    try {
        C.finishRunner(e, t, r, n), a && w.setException(e, a);
    } catch (e) {
        M.addException(e);
    }
    M.sendTrace(() => {});
}

function hapiMiddleware(e, t, r) {
    let n;
    g.setAsyncReference(M.getTrace()), g.setMainReference(), M.restart();
    const a = Date.now();
    try {
        n = C.createRunner(e, a), M.addRunner(n);
    } catch (n) {
        return A.debugLog(n), r(e, t);
    }
    const {label: s, setError: o, getTraceUrl: i} = M;
    e.epsagon = {
        label: s,
        setError: o,
        getTraceUrl: i
    };
    const c = r(e, t);
    return k(e.route.path, e.headers) ? (A.debugLog("Ignoring request: " + e.route.path), 
    c) : (A.isPromise(c) ? c.then(() => {
        handleResponse(n, e, c, a);
    }).catch(t => {
        handleResponse(n, e, c, a, t);
    }) : handleResponse(n, e, c, a), c);
}

function hapiRouteWrapper(e) {
    return function() {
        return Array.isArray(arguments[0]) || (arguments[0] = [ arguments[0] ]), arguments[0].forEach(e => {
            if (!e.handler) return;
            const t = e.handler;
            e.handler = (e, r) => g.RunInContext(M.createTracer, () => hapiMiddleware(e, r, t));
        }), e.apply(this, arguments);
    };
}

function hapiCloneWrapper(e) {
    return function(t) {
        const r = e.apply(this, [ t ]);
        return W.includes(t) || r.route && s.wrap(r, "route", hapiRouteWrapper), r;
    };
}

function hapiServerWrapper(e) {
    return function() {
        const t = e.apply(this, arguments);
        return t.route && s.wrap(t, "route", hapiRouteWrapper), t._clone && s.wrap(t, "_clone", hapiCloneWrapper), 
        t;
    };
}

var P = {
    init() {
        I.patchModule("@hapi/hapi", "server", hapiServerWrapper), I.patchModule("hapi", "server", hapiServerWrapper), 
        I.patchModule("hapi", "Server", hapiServerWrapper);
    }
};

const {utils: O, eventInterface: S, event: U, errorCode: z} = t, {extractEpsagonHeader: N} = T;

var D = {
    createRunner: function(e, t) {
        const r = new U.Event([ "express-" + a(), O.createTimestampFromTime(t), null, "runner", 0, z.ErrorCode.OK ]), n = new U.Resource([ e.hostname, "express", e.method ]);
        return r.setResource(n), S.createTraceIdMetadata(r), r;
    },
    finishRunner: function(e, t, r, n) {
        if (S.addToMetadata(e, {
            url: `${r.protocol}://${r.hostname}${r.originalUrl}`,
            status_code: t.statusCode
        }, {
            request_headers: r.headers,
            response_headers: t.getHeaders()
        }), r.query && Object.keys(r.query).length && S.addToMetadata(e, {
            query: r.query
        }), r.params && Object.keys(r.params).length && S.addToMetadata(e, {}, {
            params: r.params
        }), r.body && Object.keys(r.body).length && S.addToMetadata(e, {}, {
            request_data: r.body
        }), r.route) {
            const t = r.route.path instanceof Array ? function(e) {
                let t;
                return e.route.path.forEach(r => {
                    (function(e, t) {
                        if (e.length !== t.length) return !1;
                        for (let r = 0; r < t.length; r += 1) if (e[r] !== t[r] && e[r] && ":" !== e[r][0]) return !1;
                        return !0;
                    })(r.split("/"), e.path.split("/")) && (t = r);
                }), t;
            }(r) : r.route.path;
            t && S.addToMetadata(e, {
                route_path: r.baseUrl + t
            });
        }
        N(r.headers) && S.addToMetadata(e, {
            http_trace_id: N(r.headers)
        }), t.statusCode >= 500 && e.setErrorCode(z.ErrorCode.EXCEPTION), e.setDuration(O.createDurationTimestamp(n));
    }
}, H = {
    methods: {
        methods: [ "get", "post", "put", "head", "delete", "options", "trace", "copy", "lock", "mkcol", "move", "purge", "propfind", "proppatch", "unlock", "report", "mkactivity", "checkout", "merge", "m-search", "notify", "subscribe", "unsubscribe", "patch", "search", "connect" ]
    }
};

const {tracer: j, utils: G, moduleUtils: B, eventInterface: $} = t, {shouldIgnore: F} = T, {methods: K} = H;

function handleExpressRequestFinished(e, t, r, n, a, s) {
    if (g.setAsyncReference(t), g.setMainReference(), G.debugLog("[express] - got close event, handling response"), 
    "TRUE" === (process.env.EPSAGON_ALLOW_NO_ROUTE || "").toUpperCase() || e.route) {
        try {
            D.finishRunner(r, s, e, n), G.debugLog("[express] - finished runner");
        } catch (e) {
            j.addException(e);
        }
        G.debugLog("[express] - sending trace"), j.sendTrace(() => {}, t).then(a).then(() => {
            G.debugLog("[express] - trace sent + request resolved");
        });
    } else G.debugLog("[express] - req.route not set - not reporting trace");
}

function expressMiddleware(e, t, r) {
    g.setMainReference(), G.debugLog("[express] - starting express middleware");
    const n = j.getTrace();
    if (n || G.debugLog("[express] - no tracer found on init"), F(e.originalUrl, e.headers)) return G.debugLog("Ignoring request: " + e.originalUrl), 
    void r();
    let a;
    j.restart();
    const s = Date.now();
    try {
        a = D.createRunner(e, s), G.debugLog("[express] - created runner");
        const o = new Promise(r => {
            let o = !1;
            g.setAsyncReference(n), G.debugLog("[express] - creating response promise"), t.once("close", (function() {
                o || (o = !0, handleExpressRequestFinished(e, n, a, s, r, this));
            })), t.once("finish", (function() {
                o || (o = !0, handleExpressRequestFinished(e, n, a, s, r, this));
            }));
        });
        j.addRunner(a, o), G.debugLog("[express] - added runner");
        const {label: i, setError: c, getTraceUrl: u} = j;
        e.epsagon = {
            label: i,
            setError: c,
            getTraceUrl: u
        }, g.setMainReference(!1);
    } catch (e) {
        G.debugLog("[express] - general catch"), G.debugLog(e);
    } finally {
        G.debugLog("[express] - general finally"), r();
    }
}

function getWrappedNext(e) {
    const t = [ ...e ], r = t[t.length - 1];
    return r && "next" === r.name && (t[t.length - 1] = function(e) {
        const t = j.getTrace(), r = e;
        return function(e) {
            G.debugLog("[express] - middleware executed"), e && G.debugLog(e), g.setAsyncReference(t);
            return r(...arguments);
        };
    }(e[e.length - 1])), t;
}

function middlewareWrapper(e) {
    return 4 === e.length ? function(t, r, n, a) {
        const s = j.getTrace();
        return s && s.currRunner && $.setException(s.currRunner, t), e.apply(this, getWrappedNext(arguments));
    } : function(t, r, n) {
        return e.apply(this, getWrappedNext(arguments));
    };
}

function methodWrapper(e) {
    return function() {
        for (let e = 0; e < arguments.length - 1; e += 1) arguments[e] && "function" == typeof arguments[e] && (arguments[e] = middlewareWrapper(arguments[e]));
        return e.apply(this, arguments);
    };
}

function useWrapper(e) {
    return function() {
        return arguments.length > 1 && arguments[1] && "function" == typeof arguments[1] && (arguments[1] = middlewareWrapper(arguments[1])), 
        e.apply(this, arguments);
    };
}

function expressWrapper(e) {
    return G.debugLog("[express] - wrapping express"), function() {
        G.debugLog("[express] - express app created");
        const t = e.apply(this, arguments);
        return G.debugLog("[express] - called the original function"), this.use((e, t, r) => g.isTracingEnabled() ? g.RunInContext(j.createTracer, () => expressMiddleware(e, t, r)) : r()), 
        t;
    };
}

function expressListenWrapper(e) {
    return function() {
        const t = e.apply(this, arguments);
        return this.use((e, t, r, n) => g.isTracingEnabled() && e ? (t && t.epsagon && t.epsagon.setError({
            name: "Error",
            message: e.message,
            stack: e.stack
        }), n(e)) : n()), t;
    };
}

var J = {
    init() {
        B.patchModule("express", "init", expressWrapper, e => e.application), B.patchModule("express", "listen", expressListenWrapper, e => e.application), 
        B.patchModule("express", "use", useWrapper, e => e.Router);
        for (let e = 0; e < K.length; e += 1) B.patchModule("express", K[e], methodWrapper, e => e.Route.prototype);
    }
};

const {utils: X, eventInterface: Q, event: V, errorCode: Y} = t, {extractEpsagonHeader: Z} = T;

var ee = {
    createRunner: function(e, t) {
        const r = new V.Event([ "koa-" + a(), X.createTimestampFromTime(t), null, "runner", 0, Y.ErrorCode.OK ]), n = new V.Resource([ e.hostname, "koa", e.method ]);
        return r.setResource(n), Q.createTraceIdMetadata(r), r;
    },
    finishRunner: function(e, t, r, n) {
        Q.addToMetadata(e, {
            url: `${r.protocol}://${r.hostname}${r.path}`,
            query: r.query,
            status_code: t.status
        }, {
            request_headers: r.headers,
            response_headers: t.headers
        }), Z(r.headers) && Q.addToMetadata(e, {
            http_trace_id: Z(r.headers)
        }), t.status >= 500 && e.setErrorCode(Y.ErrorCode.EXCEPTION), e.setDuration(X.createDurationTimestamp(n));
    }
};

const {tracer: te, utils: re, moduleUtils: ne} = t, {shouldIgnore: ae} = T;

async function koaMiddleware(e, t) {
    if (ae(e.request.originalUrl, e.request.headers)) return re.debugLog("Ignoring request: " + e.request.originalUrl), 
    void await t();
    let r;
    te.restart();
    const n = Date.now();
    try {
        r = ee.createRunner(e.request, n);
        const a = new Promise(t => {
            e.res.once("finish", () => {
                if (404 !== e.response.status) {
                    try {
                        ee.finishRunner(r, e.response, e.request, n);
                    } catch (e) {
                        te.addException(e);
                    }
                    te.sendTrace(() => {}).then(t);
                }
            });
        });
        te.addRunner(r, a);
        const {label: s, setError: o, getTraceUrl: i} = te;
        e.epsagon = {
            label: s,
            setError: o,
            getTraceUrl: i
        };
    } catch (e) {
        re.debugLog(e);
    } finally {
        await t();
    }
}

function koaWrapper(e) {
    return function() {
        const t = e.apply(this, arguments);
        return this.__EPSAGON_PATCH || (this.__EPSAGON_PATCH = !0, this.use((e, t) => g.RunInContext(te.createTracer, () => koaMiddleware(e, t))), 
        this.on("error", async (e, t) => {
            t.epsagon && await t.epsagon.setError(e);
        })), t;
    };
}

var se = {
    init() {
        ne.patchModule("koa/lib/application.js", "use", koaWrapper, e => e.prototype);
    }
};

const {tracer: oe, moduleUtils: ie, eventInterface: ce, utils: ue} = t;

function pubSubSubscriberWrapper(e) {
    return function(t, r) {
        if ("message" !== t) return e.apply(this, [ t, r ]);
        const n = this;
        return e.apply(this, [ t, e => g.RunInContext(oe.createTracer, () => function(e, t, r) {
            let n;
            try {
                oe.restart();
                const {slsEvent: a, startTime: s} = ce.initializeEvent("pubsub", r.projectId, "messagePullingListener", "trigger");
                oe.addEvent(a);
                const o = e.id, i = {
                    messageId: o
                };
                let c = {};
                a.setId(o);
                const u = e.data && JSON.parse("" + e.data);
                u && "object" == typeof u && (c = u), ce.finalizeEvent(a, s, null, i, c);
                const {label: d, setError: l, getTraceUrl: p} = oe;
                e.epsagon = {
                    label: d,
                    setError: l,
                    getTraceUrl: p
                };
                const {slsEvent: g, startTime: h} = ce.initializeEvent("node_function", "message_handler", "execute", "runner");
                let f;
                try {
                    f = t(e, {});
                } catch (e) {
                    n = e;
                }
                const m = t.name;
                if (m && g.getResource().setName(m), ue.isPromise(f)) {
                    let e;
                    f.catch(t => {
                        throw e = t, t;
                    }).finally(() => {
                        ce.finalizeEvent(g, h, e), oe.sendTrace(() => {});
                    });
                } else ce.finalizeEvent(g, h, n), oe.sendTrace(() => {});
                oe.addRunner(g, f);
            } catch (e) {
                oe.addException(e);
            }
            if (n) throw n;
        }(e, r, n)) ]);
    };
}

var de = {
    init() {
        ie.patchModule("@google-cloud/pubsub/build/src/subscription", "on", pubSubSubscriberWrapper, e => e.Subscription.prototype);
    }
};

const {tracer: le, moduleUtils: pe, eventInterface: ge, utils: he} = t, fe = "Client", me = "unknown", be = "_INBOX";

function natsSubscribeWrapper(e, t, r) {
    return function(n, a, s) {
        const {opts_internal: o, callback_internal: i} = ((e, t) => {
            let r = e, n = t;
            return "function" == typeof e && (n = e, r = void 0), {
                opts_internal: r,
                callback_internal: n
            };
        })(a, s);
        let c = i;
        try {
            const e = (e => !(!e || "string" != typeof e || !e.startsWith(be)))(n);
            c = (n, a, s, o) => {
                g.RunInContext(le.createTracer, () => function(e, t, r, n, a, s, o, i) {
                    let c, u;
                    try {
                        le.restart();
                        const {slsEvent: d, startTime: l} = ge.initializeEvent("nats", r, i ? "requestMessageListener" : "subscribeMessageListener", "trigger");
                        le.addEvent(d);
                        const p = {}, g = {};
                        if (o && (p.server_host_name = o), r && (p.subject = r), n && (p.sid = n), e && (g.msg = e, 
                        s && "object" == typeof e && "TRUE" === (process.env.EPSAGON_PROPAGATE_NATS_ID || "").toUpperCase())) {
                            const {epsagon_id: t} = e;
                            t && (p.epsagon_id = t);
                        }
                        t && (g.reply = t), ge.finalizeEvent(d, l, null, p, g);
                        const {slsEvent: h, startTime: f} = ge.initializeEvent("node_function", i ? "requestMessagHandler" : "subscribeMessageHandler", "messageReceived", "runner");
                        try {
                            u = a(e, t, r, n);
                        } catch (e) {
                            c = e;
                        }
                        const m = a.name;
                        if (m && h.getResource().setName(m), he.isPromise(u)) {
                            let e;
                            u = u.catch(t => {
                                throw e = t, t;
                            }).finally(() => {
                                ge.finalizeEvent(h, f, e), le.sendTrace(() => {});
                            });
                        } else ge.finalizeEvent(h, f, c), le.sendTrace(() => {});
                        le.addRunner(h, u);
                    } catch (e) {
                        le.addException(e);
                    }
                    if (c) throw c;
                    return u;
                }(n, a, s, o, i, r, t, e));
            };
        } catch (e) {
            le.addException(e);
        }
        return e.apply(this, [ n, o, c ]);
    };
}

function natsConnectWrapper(e) {
    return function(t, r) {
        const n = e.apply(this, [ t, r ]);
        try {
            if (n && n.constructor) {
                if (n.constructor.name !== fe) return n;
                const e = n.options ? n.options.json : null, t = (a = n.currentServer).url && a.url.hostname ? a.url.hostname : me;
                s.wrap(n, "subscribe", () => natsSubscribeWrapper(n.subscribe, t, e));
            }
        } catch (e) {
            le.addException(e);
        }
        var a;
        return n;
    };
}

var ye = {
    init() {
        pe.patchModule("nats", "connect", natsConnectWrapper);
    }
};

const {tracer: Ee, moduleUtils: ve, eventInterface: Te, utils: Re} = t, {EPSAGON_HEADER: _e} = T;

function kafkaConsumerRunWrapper(e) {
    return function(t) {
        if (!t.eachMessage) return e.apply(this, [ t ]);
        const r = t.eachMessage;
        return t.eachMessage = (e => g.RunInContext(Ee.createTracer, () => function(e, t) {
            let r, n;
            try {
                Ee.restart();
                const {slsEvent: a, startTime: s} = Te.initializeEvent("kafka", e.topic, "consume", "trigger"), o = {
                    partition: e.partition,
                    offset: e.message.offset,
                    timestamp: new Date(parseInt(e.message.timestamp, 10)).toUTCString()
                };
                e.message.headers[_e] && (o[_e] = e.message.headers[_e].toString());
                const i = Object.entries(e.message.headers).reduce((e, t) => (e[t[0]] = t[1].toString(), 
                e), {});
                Ee.addEvent(a), Te.finalizeEvent(a, s, null, o, {
                    headers: i,
                    body: e.message.value.toString()
                });
                const {label: c, setError: u, getTraceUrl: d} = Ee;
                e.epsagon = {
                    label: c,
                    setError: u,
                    getTraceUrl: d
                };
                const {slsEvent: l, startTime: p} = Te.initializeEvent("node_function", "message_handler", "execute", "runner");
                try {
                    n = t(e);
                } catch (e) {
                    r = e;
                }
                if (t.name && l.getResource().setName(t.name), Re.isPromise(n)) {
                    let e;
                    n = n.catch(t => {
                        throw e = t, t;
                    }).finally(() => {
                        Te.finalizeEvent(l, p, e), Ee.sendTrace(() => {});
                    });
                } else Te.finalizeEvent(l, p, r), Ee.sendTrace(() => {});
                Ee.addRunner(l, n);
            } catch (e) {
                Ee.addException(e);
            }
            if (r) throw r;
            return n;
        }(e, r))).bind(t), e.apply(this, [ t ]);
    };
}

function kafkaConsumerWrapper(e) {
    return function(t) {
        const r = e.apply(this, [ t ]);
        return r.run && s.wrap(r, "run", kafkaConsumerRunWrapper), r;
    };
}

var qe = {
    init() {
        ve.patchModule("kafkajs", "consumer", kafkaConsumerWrapper, e => e.Kafka.prototype);
    }
};

const {tracer: xe, moduleUtils: Le, eventInterface: Ce, utils: Me} = t, {EPSAGON_HEADER: Ae} = T;

function kafkaConsumerRunWrapper$1(e) {
    return function(t, r) {
        const n = this;
        if ("message" !== t) return e.apply(this, [ t, r ]);
        if ("function" != typeof r) return e.apply(this, [ t, r ]);
        return e.apply(this, [ t, e => g.RunInContext(xe.createTracer, () => function(e, t, r) {
            let n, a;
            try {
                xe.restart();
                const {slsEvent: s, startTime: o} = Ce.initializeEvent("kafka", e.topic, "consume", "trigger"), i = {
                    partition: e.partition,
                    offset: e.offset,
                    key: e.key,
                    host: r.client.options.kafkaHost
                };
                try {
                    const t = JSON.parse(e.value);
                    t[Ae] && (i[Ae] = t[Ae].toString());
                } catch (e) {
                    Me.debugLog("kafka-node - Could not extract epsagon header");
                }
                xe.addEvent(s), Ce.finalizeEvent(s, o, null, i, {
                    body: e.value.toString()
                });
                const {label: c, setError: u, getTraceUrl: d} = xe;
                e.epsagon = {
                    label: c,
                    setError: u,
                    getTraceUrl: d
                };
                const {slsEvent: l, startTime: p} = Ce.initializeEvent("node_function", t.name || e.topic + "-consumer", "execute", "runner");
                try {
                    a = t(e);
                } catch (e) {
                    n = e;
                }
                if (Me.isPromise(a)) {
                    let e;
                    a = a.catch(t => {
                        throw e = t, t;
                    }).finally(() => {
                        Ce.finalizeEvent(l, p, e), xe.sendTrace(() => {});
                    });
                } else Ce.finalizeEvent(l, p, n), xe.sendTrace(() => {});
                xe.addRunner(l, a);
            } catch (e) {
                xe.addException(e);
            }
            if (n) throw n;
            return a;
        }(e, r, n)) ]);
    };
}

var we = {
    init() {
        Le.patchModule("kafka-node", "on", kafkaConsumerRunWrapper$1, e => e.Consumer.prototype);
    }
};

const {tracer: Ie, moduleUtils: ke, eventInterface: We, utils: Pe, sqsUtils: Oe} = t;

function sqsConsumerWrapper(e) {
    return function(t) {
        Pe.debugLog("sqs-consumer - inside wrapper"), Pe.debugLog("sqs-consumer - options: " + t);
        const r = e.apply(this, [ t ]), patchedCallback = e => g.RunInContext(Ie.createTracer, () => function(e, t) {
            Pe.debugLog("sqs-consumer - starting middleware");
            const r = Array.isArray(e) ? e[0] : e;
            let n;
            try {
                Ie.restart();
                const {queueName: a, awsAccount: s, region: o} = function(e) {
                    let t = "", r = "", n = "";
                    if (e.startsWith("https://vpce")) {
                        const [r, a, s, o] = e.split("/");
                        n = s.split(".")[2], t = o;
                    } else {
                        const [a, s, o, i, c] = e.split("/");
                        t = c, r = i, n = o.split(".")[1];
                    }
                    return {
                        queueName: t,
                        awsAccount: r,
                        region: n
                    };
                }(t.queueUrl);
                Pe.debugLog("sqs-consumer - parsed queue url", a, s, o);
                const {slsEvent: i, startTime: c} = We.initializeEvent("sqs", a, Array.isArray(e) ? "ReceiveMessages" : "ReceiveMessage", "trigger");
                Ie.addEvent(i), We.finalizeEvent(i, c, null, {
                    aws_account: s,
                    region: o,
                    md5_of_message_body: r.MD5OfBody,
                    message_id: r.MessageId
                }, {
                    message_body: r.Body,
                    message_attributed: r.MessageAttributes
                }), Pe.debugLog("sqs-consumer - created sqs event");
                const u = Oe.getSNSTrigger([ r ]);
                null != u && (Pe.debugLog("sqs-consumer - created sns event"), We.addToMetadata(i, {
                    "SNS Trigger": u
                }));
                const {label: d, setError: l, getTraceUrl: p} = Ie;
                r.epsagon = {
                    label: d,
                    setError: l,
                    getTraceUrl: p
                };
                const {slsEvent: g, startTime: h} = We.initializeEvent("node_function", "message_handler", "execute", "runner");
                let f;
                Pe.debugLog("sqs-consumer - initialized runner event");
                try {
                    f = t.originalHandleMessage(e), Pe.debugLog("sqs-consumer - executed original handler");
                } catch (e) {
                    Pe.debugLog("sqs-consumer - error in original handler"), n = e;
                }
                if (t.originalHandleMessage.name && (Pe.debugLog("sqs-consumer - set handler name"), 
                g.getResource().setName(t.originalHandleMessage.name)), Pe.isPromise(f)) {
                    let e;
                    Pe.debugLog("sqs-consumer - result is promise"), f.catch(t => {
                        throw Pe.debugLog("sqs-consumer - original handler threw error"), e = t, t;
                    }).finally(() => {
                        Pe.debugLog("sqs-consumer - finalizing event"), We.finalizeEvent(g, h, e), Pe.debugLog("sqs-consumer - sending trace"), 
                        Ie.sendTrace(() => {}).then(() => {
                            Pe.debugLog("sqs-consumer - trace sent");
                        }), Pe.debugLog("sqs-consumer - post send");
                    });
                } else Pe.debugLog("sqs-consumer - response not promise"), Pe.debugLog("sqs-consumer - finalizing event"), 
                We.finalizeEvent(g, h, n), Pe.debugLog("sqs-consumer - sending trace"), Ie.sendTrace(() => {}).then(() => {
                    Pe.debugLog("sqs-consumer - trace sent");
                }), Pe.debugLog("sqs-consumer - post send");
                Ie.addRunner(g, f), Pe.debugLog("sqs-consumer - added runner");
            } catch (e) {
                Pe.debugLog("sqs-consumer - general error " + e), Ie.addException(e);
            }
            if (n) throw Pe.debugLog("sqs-consumer - rethrowing original sync error"), n;
        }(e, r));
        return t.handleMessage ? (Pe.debugLog("sqs-consumer - wrapping handleMessage"), 
        r.originalHandleMessage = r.handleMessage, r.handleMessage = patchedCallback) : t.handleMessageBatch && (Pe.debugLog("sqs-consumer - wrapping handleMessageBatch"), 
        r.originalHandleMessage = r.handleMessageBatch, r.handleMessageBatch = patchedCallback), 
        Pe.debugLog("sqs-consumer - done wrapper"), r;
    };
}

var Se = {
    init() {
        ke.patchModule("sqs-consumer", "create", sqsConsumerWrapper, e => e.Consumer);
    }
};

const {tracer: Ue, moduleUtils: ze, eventInterface: Ne, utils: De} = t, {EPSAGON_HEADER: He} = T;

function amqplibConsumerWrapper(e) {
    return function(t, r, n, a) {
        const s = this;
        let o = r;
        return "function" == typeof r && (o = e => g.RunInContext(Ue.createTracer, () => function(e, t, r) {
            let n, a, s, o;
            const i = Ue.getTrace();
            g.setAsyncReference(i), g.setMainReference();
            try {
                if (e.properties.headers.bunnyBus) return De.debugLog("[amqplib] Skipping BunnyBus messages"), 
                t(e);
                Ue.restart();
                const {slsEvent: n, startTime: a} = Ne.initializeEvent("rabbitmq", e.fields.routingKey, "consume", "trigger");
                De.debugLog("[amqplib] Done initializing event");
                const i = {
                    exchange: e.fields.exchange,
                    redelivered: e.fields.redelivered,
                    host: r.connection.stream._host,
                    consumer_tag: e.fields.consumerTag
                };
                e.properties.headers[He] && (i[He] = e.properties.headers[He].toString()), Ue.addEvent(n), 
                De.debugLog("[amqplib] Event added"), Ne.finalizeEvent(n, a, null, i, {
                    headers: e.properties.headers,
                    message: e.content.toString()
                });
                const {label: c, setError: u, getTraceUrl: d} = Ue;
                e.epsagon = {
                    label: c,
                    setError: u,
                    getTraceUrl: d
                };
                const l = t && t.name ? t.name : e.fields.routingKey + "-consumer", {slsEvent: p, startTime: g} = Ne.initializeEvent("node_function", l, "execute", "runner");
                s = p, o = g, De.debugLog("[amqplib] Runner initialized");
            } catch (e) {
                De.debugLog("[amqplib] Exception initializing"), Ue.addException(e);
            }
            try {
                a = t(e), De.debugLog("[amqplib] Original runner ran");
            } catch (e) {
                De.debugLog("[amqplib] Original runner got an error"), n = e;
            }
            try {
                if (s) {
                    if (De.isPromise(a)) {
                        let e;
                        De.debugLog("[amqplib] Original runner is a promise"), a = a.catch(t => {
                            throw De.debugLog("[amqplib] Original runner in catch"), e = t, t;
                        }).finally(() => {
                            De.debugLog("[amqplib] Original runner in finally"), Ne.finalizeEvent(s, o, e), 
                            Ue.sendTrace(() => {}), De.debugLog("[amqplib] Trace sent");
                        });
                    } else De.debugLog("[amqplib] Original runner is not a promise"), Ne.finalizeEvent(s, o, n), 
                    Ue.sendTrace(() => {});
                    De.debugLog("[amqplib] Runner added"), Ue.addRunner(s, a);
                }
            } catch (e) {
                De.debugLog("[amqplib] Exception adding runner"), Ue.addException(e);
            }
            if (n) throw n;
            return De.debugLog("[amqplib] Return result"), a;
        }(e, r, s))), e.apply(this, [ t, o, n, a ]);
    };
}

var je = {
    init() {
        ze.patchModule("amqplib/lib/callback_model.js", "consume", amqplibConsumerWrapper, e => e.Channel.prototype), 
        ze.patchModule("amqplib/lib/channel_model.js", "consume", amqplibConsumerWrapper, e => e.Channel.prototype);
    }
};

const {tracer: Ge, moduleUtils: Be, eventInterface: $e, utils: Fe} = t, {EPSAGON_HEADER: Ke} = T;

function amqpSubscribeWrapper(e) {
    return function(t, r, n) {
        const a = this, s = "function" == typeof t ? t : r;
        let o = s;
        return "function" == typeof s && (o = (e, t, r, n) => g.RunInContext(Ge.createTracer, () => function(e, t, r, n, a, s) {
            let o, i, c, u;
            try {
                if (r.bunnyBus) return Fe.debugLog("[amqp] Skipping BunnyBus messages"), s(t, r, n, a);
                Ge.restart();
                const {slsEvent: o, startTime: i} = $e.initializeEvent("rabbitmq", n.routingKey, "consume", "trigger");
                Fe.debugLog("[amqp] Done initializing event");
                const d = {
                    exchange: n.exchange,
                    redelivered: n.redelivered,
                    queue: n.queue,
                    host: e.connection.options.host,
                    vhost: e.connection.options.vhost,
                    consumer_tag: n.consumerTag
                };
                r[Ke] && (d[Ke] = r[Ke].toString()), Ge.addEvent(o), Fe.debugLog("[amqp] Event added"), 
                $e.finalizeEvent(o, i, null, d, {
                    headers: r,
                    message: JSON.stringify(t)
                });
                const {label: l, setError: p, getTraceUrl: g} = Ge;
                t.epsagon = {
                    label: l,
                    setError: p,
                    getTraceUrl: g
                };
                const h = s && s.name ? s.name : n.routingKey + "-consumer", {slsEvent: f, startTime: m} = $e.initializeEvent("node_function", h, "execute", "runner");
                c = f, u = m, Fe.debugLog("[amqp] Runner initialized");
            } catch (e) {
                Fe.debugLog("[amqp] Exception initializing"), Ge.addException(e);
            }
            try {
                i = s(t, r, n, a), Fe.debugLog("[amqp] Original runner ran");
            } catch (e) {
                Fe.debugLog("[amqp] Original runner got an error"), o = e;
            }
            try {
                if (c) {
                    if (Fe.isPromise(i)) {
                        let e;
                        Fe.debugLog("[amqp] Original runner is a promise"), i = i.catch(t => {
                            throw Fe.debugLog("[amqp] Original runner in catch"), e = t, t;
                        }).finally(() => {
                            Fe.debugLog("[amqp] Original runner in finally"), $e.finalizeEvent(c, u, e), Ge.sendTrace(() => {}), 
                            Fe.debugLog("[amqp] Trace sent");
                        });
                    } else Fe.debugLog("[amqp] Original runner is not a promise"), $e.finalizeEvent(c, u, o), 
                    Ge.sendTrace(() => {});
                    Fe.debugLog("[amqp] Runner added"), Ge.addRunner(c, i);
                }
            } catch (e) {
                Fe.debugLog("[amqp] Exception adding runner"), Ge.addException(e);
            }
            if (o) throw o;
            return Fe.debugLog("[amqp] Return result"), i;
        }(a, e, t, r, n, s))), "function" == typeof t ? t = o : r = o, e.apply(this, [ t, r, n ]);
    };
}

var Je = {
    init() {
        Be.patchModule("amqp/lib/queue.js", "subscribe", amqpSubscribeWrapper, e => e.prototype);
    }
};

const {tracer: Xe, moduleUtils: Qe, eventInterface: Ve, utils: Ye} = t, {EPSAGON_HEADER: Ze} = T;

function bunnybusConsumerWrapper(e) {
    return function({queue: t, handlers: r, options: n}) {
        if (!t) return Ye.debugLog("Found BunnyBus <7.0.0, skipping instrumentation."), 
        e.apply(this, [ {
            queue: t,
            handlers: r,
            options: n
        } ]);
        try {
            const e = this;
            e.__EPSAGON_PATCH = {}, Object.keys(r).forEach(t => {
                const n = r[t];
                "function" == typeof r[t] && e.__EPSAGON_PATCH && !e.__EPSAGON_PATCH[t] && (e.__EPSAGON_PATCH[t] = !0, 
                r[t] = e => g.RunInContext(Xe.createTracer, () => function(e, t, r, n, a) {
                    let s, o;
                    try {
                        const r = Xe.getTrace();
                        g.setAsyncReference(r), g.setMainReference(), Xe.restart();
                        const {slsEvent: i, startTime: c} = Ve.initializeEvent("rabbitmq", a.metaData.headers.routeKey, "consume", "trigger"), u = {
                            host: e.hostname,
                            vhost: e.vhost,
                            "messaging.message_payload_size_bytes": JSON.stringify(a.message).length
                        };
                        a.metaData.headers[Ze] && (u[Ze] = a.metaData.headers[Ze].toString()), Xe.addEvent(i), 
                        Ve.finalizeEvent(i, c, null, u, {
                            headers: a.metaData.headers,
                            message: a.message
                        });
                        const {label: d, setError: l, getTraceUrl: p} = Xe;
                        a.epsagon = {
                            label: d,
                            setError: l,
                            getTraceUrl: p
                        };
                        const h = t && t.name ? t.name : n + "-consumer", {slsEvent: f, startTime: m} = Ve.initializeEvent("node_function", h, "execute", "runner");
                        Ve.createTraceIdMetadata(f);
                        try {
                            o = t(a);
                        } catch (e) {
                            s = e;
                        }
                        if (Ye.isPromise(o)) {
                            let e;
                            o = o.catch(t => {
                                throw e = t, t;
                            }).finally(() => {
                                g.setAsyncReference(r), Ve.finalizeEvent(f, m, e), Xe.sendTrace(() => {});
                            });
                        } else Ve.finalizeEvent(f, m, s), Xe.sendTrace(() => {});
                        Xe.addRunner(f, o);
                    } catch (e) {
                        Xe.addException(e);
                    }
                    if (s) throw s;
                    return o;
                }(this.config, n, 0, t, e)));
            });
        } catch (e) {
            Ye.debugLog("Could not enable BunnyBus tracing - " + e);
        }
        return e.apply(this, [ {
            queue: t,
            handlers: r,
            options: n
        } ]);
    };
}

var et = {
    init() {
        Qe.patchModule("@tenna-llc/bunnybus/lib/index.js", "subscribe", bunnybusConsumerWrapper, e => e.prototype);
    }
};

const {tracer: tt, moduleUtils: rt, eventInterface: nt, utils: at, httpHelpers: st} = t, {EPSAGON_HEADER: ot} = T;

function superagentWrapper(e) {
    return function(t, r, n) {
        const a = e.apply(this, [ t, r, n ]);
        try {
            const {hostname: e, pathname: r} = new URL(t), {slsEvent: n, startTime: s} = nt.initializeEvent("http", e, a.method, "http"), o = st.generateEpsagonTraceId();
            "TRUE" !== (process.env.EPSAGON_DISABLE_HTTP_TRACE_ID || "").toUpperCase() && a.set(ot, o), 
            nt.addToMetadata(n, {
                url: t,
                http_trace_id: o
            }, {
                path: r
            });
            const i = new Promise(e => {
                a.once("end", () => {
                    nt.addToMetadata(n, {
                        status_code: a.res.statusCode
                    }, {
                        request_headers: a.header,
                        response_headers: a.res.headers
                    }), st.setJsonPayload(n, "request_body", a._data), st.setJsonPayload(n, "response_body", a.res.text, a.res.headers["content-encoding"]), 
                    n.setDuration(at.createDurationTimestamp(s)), e();
                });
            });
            tt.addEvent(n, i);
        } catch (e) {
            tt.addException(e);
        }
        return a;
    };
}

var it = {
    init() {
        [ "post", "get", "put", "patch", "delete" ].forEach(e => {
            rt.patchModule("superagent", e, superagentWrapper);
        });
    }
};

const {tracer: ct, moduleUtils: ut, eventInterface: dt, utils: lt, httpHelpers: pt} = t, {EPSAGON_HEADER: gt} = T;

function superagentWrapper$1(e) {
    return function(t) {
        const r = e.apply(this, [ t ]);
        try {
            const {hostname: e, pathname: r} = new URL(t.url), {slsEvent: n, startTime: a} = dt.initializeEvent("http", e, t.method, "http"), s = pt.generateEpsagonTraceId();
            "TRUE" !== (process.env.EPSAGON_DISABLE_HTTP_TRACE_ID || "").toUpperCase() && (t.header[gt] = s), 
            dt.addToMetadata(n, {
                url: t.url,
                http_trace_id: s
            }, {
                request_headers: t.header,
                path: r
            });
            const o = new Promise(e => {
                t.once("response", t => {
                    dt.addToMetadata(n, {
                        status_code: t.statusCode
                    }, {
                        response_headers: t.headers
                    }), pt.setJsonPayload(n, "response_body", t.text, t.headers["content-encoding"]), 
                    n.setDuration(lt.createDurationTimestamp(a)), e();
                });
            });
            ct.addEvent(n, o);
        } catch (e) {
            ct.addException(e);
        }
        return r;
    };
}

var ht = {
    init() {
        ut.patchModule("@tenna-llc/superagent-wrapper", "_setDefaults", superagentWrapper$1, e => e.ProxyAgent.prototype);
    }
};

const {tracer: ft, moduleUtils: mt} = t;

function redisClientWrapper(e) {
    return function(t) {
        try {
            if (!1 === this.ready || !1 === this.stream.writable) return e.apply(this, [ t ]);
            const r = ft.getTrace(), {callback: n} = t;
            t.callback = (e, t) => {
                g.setAsyncReference(r), n && n(e, t);
            };
        } catch (e) {
            ft.addException(e);
        }
        return e.apply(this, [ t ]);
    };
}

var bt = {
    init() {
        mt.patchModule("redis", "internal_send_command", redisClientWrapper, e => e.RedisClient.prototype);
    }
};

const {tracer: yt, moduleUtils: Et} = t;

function mysqlQueryWrapper(e) {
    return function(t, r, n) {
        try {
            let a, s, o = !1;
            const i = yt.getTrace();
            t.onResult ? (s = t.values, a = t.onResult) : ({params: s, callback: a} = function(e, t) {
                const r = void 0 === t && e instanceof Function;
                return {
                    params: r ? [] : e,
                    callback: r ? e : t
                };
            }(r, n)), void 0 === a && t._callback && (a = t._callback, o = !0);
            const patchedCallback = (e, t, r) => {
                g.setAsyncReference(i), a && a(e, t, r);
            };
            return t.onResult && (t.onResult = patchedCallback), o && (t._callback = patchedCallback), 
            e.apply(this, [ t, s, a && !o ? patchedCallback : n ]);
        } catch (e) {
            yt.addException(e);
        }
        return e.apply(this, [ t, r, n ]);
    };
}

function mysqlGetConnectionWrapper(e) {
    return function(t) {
        let r = t;
        try {
            const e = yt.getTrace();
            r = (r, n) => {
                g.setAsyncReference(e), t && t(r, n);
            };
        } catch (e) {
            yt.addException(e);
        }
        return e.apply(this, [ r ]);
    };
}

var vt = {
    init() {
        Et.patchModule("mysql2", "query", mysqlQueryWrapper, e => e.Connection.prototype), 
        Et.patchModule("mysql2", "execute", mysqlQueryWrapper, e => e.Connection.prototype), 
        Et.patchModule("mysql/lib/Connection.js", "query", mysqlQueryWrapper, e => e.prototype), 
        Et.patchModule("mysql/lib/Pool.js", "getConnection", mysqlGetConnectionWrapper, e => e.prototype);
    }
};

const {tracer: Tt, moduleUtils: Rt} = t;

function mongodbAsyncPasser(...e) {
    const t = e[e.length - 1], r = e[e.length - 2];
    let n = r;
    try {
        const e = Tt.getTrace();
        n = (t, n) => {
            g.setAsyncReference(e), r && r(t, n);
        };
    } catch (e) {
        Tt.addException(e);
    }
    return arguments[e.length - 2] = n, Array.prototype.pop.apply(arguments), t.apply(this, arguments);
}

function mongodbWrapper(e) {
    return function(...t) {
        return mongodbAsyncPasser(...t, e);
    };
}

function mongodbCommandWrapper(e) {
    return function(...t) {
        const r = t[2];
        return r && r.ismaster ? e.apply(this, t) : mongodbAsyncPasser(...t, e);
    };
}

var _t = {
    init() {
        Rt.patchModule("mongodb/lib/core/wireprotocol/index.js", "insert", mongodbWrapper, e => e), 
        Rt.patchModule("mongodb/lib/core/wireprotocol/index.js", "update", mongodbWrapper, e => e), 
        Rt.patchModule("mongodb/lib/core/wireprotocol/index.js", "remove", mongodbWrapper, e => e), 
        Rt.patchModule("mongodb/lib/core/wireprotocol/index.js", "query", mongodbWrapper, e => e), 
        Rt.patchModule("mongodb/lib/core/wireprotocol/index.js", "getMore", mongodbWrapper, e => e), 
        Rt.patchModule("mongodb/lib/core/wireprotocol/index.js", "command", mongodbCommandWrapper, e => e);
    }
};

const {tracer: qt, moduleUtils: xt, eventInterface: Lt, utils: Ct} = t;

function websocketEmitterWrapper(e) {
    return function(t, r) {
        if ("message" !== t) return e.apply(this, [ t, r ]);
        const n = this;
        return e.apply(this, [ t, e => g.RunInContext(qt.createTracer, () => function(e, t, r) {
            let n;
            try {
                qt.restart();
                const {slsEvent: s, startTime: o} = Lt.initializeEvent("websocket", (a = r._socket) ? a.localAddress : "websocket", "messagePullingListener", "trigger");
                qt.addEvent(s);
                const i = {
                    message: e
                };
                Lt.finalizeEvent(s, o, null, i);
                const {slsEvent: c, startTime: u} = Lt.initializeEvent("node_function", "message_handler", "execute", "runner");
                let d;
                Lt.createTraceIdMetadata(c);
                const {label: l, setError: p, setWarning: g, getTraceUrl: h} = qt;
                qt.addRunner(c);
                try {
                    d = t(e, {
                        label: l,
                        setError: p,
                        setWarning: g,
                        getTraceUrl: h
                    });
                } catch (e) {
                    n = e;
                }
                const f = t.name;
                if (f && c.getResource().setName(f), Ct.isPromise(d)) {
                    let e;
                    qt.addPendingEvent(c, d), d.catch(t => {
                        throw e = t, t;
                    }).finally(() => {
                        Lt.finalizeEvent(c, u, e), qt.sendTrace(() => {});
                    });
                } else Lt.finalizeEvent(c, u, n), qt.sendTrace(() => {});
            } catch (e) {
                qt.addException(e);
            }
            var a;
            if (n) throw n;
        }(e, r, n)) ]);
    };
}

var Mt = {
    init() {
        xt.patchModule("ws", "on", websocketEmitterWrapper, e => e.prototype);
    }
};

const {utils: At, eventInterface: wt, event: It, errorCode: kt} = t, {extractEpsagonHeader: Wt} = T;

var Pt = {
    createRunner: function(e, t) {
        const r = new It.Event([ "restify-" + a(), At.createTimestampFromTime(t), null, "runner", 0, kt.ErrorCode.OK ]), n = new It.Resource([ e.headers.host, "restify", e.method ]);
        return r.setResource(n), wt.createTraceIdMetadata(r), r;
    },
    finishRunner: function(e, t, r, n, a) {
        e.setDuration(At.createDurationTimestamp(n)), wt.addToMetadata(e, {
            url: t.url,
            route: t.route.path,
            status_code: r.statusCode
        }, {
            request_headers: t.headers,
            params: t.params,
            response_headers: r.headers
        }), Wt(t.headers) && wt.addToMetadata(e, {
            http_trace_id: Wt(t.headers)
        }), a && wt.setException(e, a), r.statusCode >= 500 && e.setErrorCode(kt.ErrorCode.EXCEPTION);
    }
};

const {tracer: Ot, utils: St, moduleUtils: Ut} = t, {shouldIgnore: zt} = T, Nt = [ "get", "post", "put", "patch", "head", "opts", "del" ];

function restifyWrapper(e) {
    return function(t, r) {
        const n = r;
        return e.apply(this, [ t, (e, t, r) => g.RunInContext(Ot.createTracer, () => function(e, t, r, n) {
            let a, s, o, i = Promise.resolve();
            const c = Date.now();
            try {
                if (zt(e.url, e.headers)) return St.debugLog("Ignoring request: " + e.url), n(e, t, r);
                Ot.restart(), o = Pt.createRunner(e, c), Ot.addRunner(o);
                const {label: u, setError: d, getTraceUrl: l} = Ot;
                e.epsagon = {
                    label: u,
                    setError: d,
                    getTraceUrl: l
                };
                try {
                    s = n(e, t, r);
                } catch (e) {
                    a = e;
                }
                if (St.isPromise(s)) {
                    let r;
                    s = s.catch(e => {
                        throw r = e, e;
                    }).finally(() => {
                        Pt.finishRunner(o, e, t, c, r), Ot.sendTrace(() => {});
                    });
                } else Pt.finishRunner(o, e, t, c, a), i = Ot.sendTrace(() => {});
            } catch (e) {
                Ot.addException(e);
            }
            return a ? (i.then(() => {
                throw a;
            }), s) : s;
        }(e, t, r, n)) ]);
    };
}

var Dt = {
    init() {
        for (let e = 0; e < Nt.length; e += 1) Ut.patchModule("restify/lib/server", Nt[e], restifyWrapper, e => e.prototype);
    }
};

const {utils: Ht, eventInterface: jt, event: Gt, errorCode: Bt} = t, {extractEpsagonHeader: $t} = T;

var Ft = {
    createRunner: function(e, t) {
        const r = new Gt.Event([ "fastify-" + a(), Ht.createTimestampFromTime(t), null, "runner", 0, Bt.ErrorCode.OK ]), n = new Gt.Resource([ e.hostname, "fastify", e.method ]);
        return r.setResource(n), jt.createTraceIdMetadata(r), r;
    },
    finishRunner: function(e, t, r, n, a) {
        jt.addToMetadata(e, {
            url: `${r.protocol}://${r.hostname}${r.url}`,
            status_code: t.statusCode
        }, {
            request_headers: r.headers,
            response_headers: t.getHeaders()
        }), r.query && Object.keys(r.query).length && jt.addToMetadata(e, {
            query: r.query
        }), r.params && Object.keys(r.params).length && jt.addToMetadata(e, {}, {
            params: r.params
        }), a && Object.keys(a).length && jt.addToMetadata(e, {}, {
            request_data: a
        }), r.routerPath && jt.addToMetadata(e, {
            route: r.routerPath
        }), $t(r.headers) && jt.addToMetadata(e, {
            http_trace_id: $t(r.headers)
        }), t.statusCode >= 500 && e.setErrorCode(Bt.ErrorCode.EXCEPTION), e.setDuration(Ht.createDurationTimestamp(n));
    }
};

const {tracer: Kt, utils: Jt, moduleUtils: Xt, eventInterface: Qt, httpHelpers: Vt} = t, {shouldIgnore: Yt} = T;

function handleResponse$1(e, t, r, n, a, s, o) {
    g.setAsyncReference(e), g.setMainReference(), Jt.debugLog("[fastify] - got close event, handling response");
    try {
        Ft.finishRunner(t, r, n, a, o), Jt.debugLog("[fastify] - finished runner");
    } catch (e) {
        Kt.addException(e);
    }
    Jt.debugLog("[fastify] - sending trace"), Kt.sendTrace(() => {}, e).then(s).then(() => {
        Jt.debugLog("[fastify] - trace sent + request resolved");
    });
}

function fastifyMiddleware(e, t) {
    g.setMainReference(), Jt.debugLog("[fastify] - starting middleware");
    const r = Kt.getTrace();
    if (r || Jt.debugLog("[fastify] - no tracer found on init"), Yt(e.url, e.headers)) return void Jt.debugLog("Ignoring request: " + e.url);
    const n = [];
    let a;
    e.raw.on("data", e => Vt.addChunk(e, n)), Kt.restart();
    const s = Date.now();
    try {
        a = Ft.createRunner(e, s), Jt.debugLog("[fastify] - created runner");
        const o = new Promise(o => {
            let i = !1;
            g.setAsyncReference(r), Jt.debugLog("[fastify] - creating response promise"), t.raw.once("finish", () => {
                Jt.debugLog("[fastify] - got to finish event. isFinished=" + i), i || (i = !0, handleResponse$1(r, a, t, e, s, o, Buffer.concat(n).toString()));
            }), t.raw.once("close", () => {
                Jt.debugLog("[fastify] - got to close event. isFinished=" + i), i || (i = !0, handleResponse$1(r, a, t, e, s, o, Buffer.concat(n).toString()));
            });
        });
        e.context._EPSAGON_EVENT = a, e.context._originalErrorHandler || (e.context._originalErrorHandler = e.context.errorHandler, 
        e.context.errorHandler = (t, r, n) => {
            Qt.setException(r.context._EPSAGON_EVENT, t), e.context._originalErrorHandler(t, r, n);
        }), Kt.addRunner(a, o), Jt.debugLog("[fastify] - added runner");
        const {label: i, setError: c, getTraceUrl: u} = Kt;
        e.epsagon = {
            label: i,
            setError: c,
            getTraceUrl: u
        }, g.setMainReference(!1);
    } catch (e) {
        Jt.debugLog("[fastify] - general catch"), Jt.debugLog(e);
    } finally {
        Jt.debugLog("[fastify] - general finally");
    }
}

function fastifyWrapper(e) {
    return Jt.debugLog("[fastify] - wrapping"), function(t, r, n, a, s) {
        try {
            if (s && s instanceof Function && "runPreParsing" !== s.name) return Jt.debugLog("[fastify] - incoming callback type is not runPreParsing"), 
            e.apply(this, arguments);
            Jt.debugLog("[fastify] - incoming request"), g.isTracingEnabled() && g.RunInContext(Kt.createTracer, () => fastifyMiddleware(n, a));
        } catch (e) {
            Jt.debugLog("[fastify] - failed wrapping " + e);
        }
        return Jt.debugLog("[fastify] - calling the original function"), e.apply(this, arguments);
    };
}

var Zt = {
    init() {
        Xt.patchModule("fastify/lib/hooks.js", "hookRunner", fastifyWrapper);
    }
};

const {config: er, utils: tr} = t, rr = {
    express: J,
    hapi: P,
    koa: se,
    pubsub: de,
    nats: ye,
    kafkajs: qe,
    kafkanode: we,
    sqsconsumer: Se,
    amqplib: je,
    amqp: Je,
    bunnybus: et,
    superagent: it,
    superagentWrapper: ht,
    redis: bt,
    ws: Mt,
    restify: Dt,
    mysql: vt,
    mongodb: _t
};

function patch(e) {
    try {
        e.init();
    } catch (e) {
        "TRUE" === (process.env.EPSAGON_DEBUG || "").toUpperCase() && tr.debugLog(e);
    }
}

er.getConfig().isEpsagonPatchDisabled || (g.init(), er.getConfig().patchWhitelist ? er.getConfig().patchWhitelist.forEach(e => {
    rr[e] ? (tr.debugLog("[FRM-PATCHER] Whitelisting " + e), patch(rr[e])) : tr.debugLog("[FRM-PATCHER] Unable to find lib to patch: " + e);
}) : [ J, P, se, de, ye, qe, we, Se, je, Je, et, it, ht, bt, Mt, Dt, Zt, vt, _t ].forEach(patch)), 
t.disableAll = () => {
    t.unpatch(), g.disableTracing();
}, t.ignoreEndpoints = T.ignoreEndpoints;

var nr = t;

module.exports = nr;
